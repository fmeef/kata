// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field
// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'api.dart';
import 'api/db.dart';
import 'api/db/connection.dart';
import 'api/db/entities.dart';
import 'api/db/migrations.dart';
import 'api/db/store.dart';
import 'api/pgp.dart';
import 'api/pgp/cert.dart';
import 'api/pgp/fingerprint.dart';
import 'api/pgp/import.dart';
import 'api/pgp/keys.dart';
import 'api/pgp/sign.dart';
import 'api/pgp/wot/network.dart';
import 'api/pgp/wot/path.dart';
import 'api/ser.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:uuid/uuid.dart';
part 'frb_generated.freezed.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -177277035;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_kata',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  GenerateCert crateApiPgpKeysGenerateCertComment({
    required GenerateCert that,
    required String comment,
  });

  Future<PgpCertWithIds> crateApiPgpKeysGenerateCertGenerate({
    required GenerateCert that,
  });

  GenerateCert crateApiPgpKeysGenerateCertName({
    required GenerateCert that,
    required String name,
  });

  GenerateCert crateApiPgpKeysGenerateCertOnline({
    required GenerateCert that,
    required bool online,
  });

  UserHandle crateApiPgpCertMaybeCertFingerprint({required MaybeCert that});

  List<String>? crateApiPgpCertMaybeCertMaybeIds({required MaybeCert that});

  String crateApiDbEntitiesNewsGroupAutoAccessorGetDescription({
    required NewsGroup that,
  });

  String crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName({
    required NewsGroup that,
  });

  UuidValue? crateApiDbEntitiesNewsGroupAutoAccessorGetParent({
    required NewsGroup that,
  });

  Uint8List? crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash({
    required NewsGroup that,
  });

  bool crateApiDbEntitiesNewsGroupAutoAccessorGetSent({
    required NewsGroup that,
  });

  UuidValue crateApiDbEntitiesNewsGroupAutoAccessorGetUuid({
    required NewsGroup that,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetDescription({
    required NewsGroup that,
    required String description,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName({
    required NewsGroup that,
    required String groupName,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetParent({
    required NewsGroup that,
    UuidValue? parent,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash({
    required NewsGroup that,
    Uint8List? parentHash,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetSent({
    required NewsGroup that,
    required bool sent,
  });

  void crateApiDbEntitiesNewsGroupAutoAccessorSetUuid({
    required NewsGroup that,
    required UuidValue uuid,
  });

  Future<void> crateApiDbEntitiesNewsGroupDelete({
    required NewsGroup that,
    required SqliteDb conn,
  });

  Future<bool> crateApiDbEntitiesNewsGroupHasParams();

  Future<void> crateApiDbEntitiesNewsGroupInsert({
    required NewsGroup that,
    required SqliteDb conn,
  });

  Future<void> crateApiDbEntitiesNewsGroupInsertOnConflict({
    required NewsGroup that,
    required SqliteDb conn,
    required OnConflict onConflict,
  });

  Future<bool> crateApiDbEntitiesNewsGroupIsEntity();

  Future<void> crateApiDbEntitiesNewsGroupUpdate({
    required NewsGroup that,
    required SqliteDb conn,
  });

  Future<List<PgpCertWithIds>> crateApiPgpAppAllOwnedCerts({
    required PgpApp that,
  });

  Future<List<CertificationSet>> crateApiPgpAppCertificationsOf({
    required PgpApp that,
    required String target,
    BigInt? minDepth,
  });

  Future<List<(String, UserId)>> crateApiPgpAppCertifiedUserids({
    required PgpApp that,
  });

  Future<List<UserId>> crateApiPgpAppCertifiedUseridsOf({
    required PgpApp that,
    required String fpr,
  });

  Future<PgpApp> crateApiPgpAppCreate({required Config config});

  Future<void> crateApiPgpAppDeleteCert({
    required PgpApp that,
    required UserHandle fingerprint,
  });

  Future<void> crateApiPgpAppDeletePrivateKey({
    required PgpApp that,
    required UserHandle fingerprint,
  });

  Future<String> crateApiPgpAppExportArmor({required PgpApp that});

  Future<void> crateApiPgpAppExportFile({
    required PgpApp that,
    required String file,
  });

  Future<void> crateApiPgpAppFillFromKeyserver({
    required PgpApp that,
    required UserHandle fingerprint,
    required String server,
  });

  GenerateCert crateApiPgpAppGenerateKey({
    required PgpApp that,
    required String email,
  });

  Future<PgpCertWithIds?> crateApiPgpAppGetCertByRole({
    required PgpApp that,
    required String role,
  });

  SqliteDb crateApiPgpAppGetDb({required PgpApp that});

  Future<List<String>> crateApiPgpAppGetFingerprints({required PgpApp that});

  Future<PgpCertWithIds> crateApiPgpAppGetKeyFromFingerprint({
    required PgpApp that,
    required UserHandle fingerprint,
  });

  Future<Uint8List> crateApiPgpAppGetQr({
    required PgpApp that,
    required String resource,
    String? handle,
    String? description,
    required UserHandle key,
    required bool fullKey,
  });

  Future<PgpCertWithIds> crateApiPgpAppGetStubFromFingerprint({
    required PgpApp that,
    required UserHandle fingerprint,
  });

  Watcher crateApiPgpAppGetWatcher({required PgpApp that});

  Future<void> crateApiPgpAppImportCerts({
    required PgpApp that,
    required PgpImport import_,
  });

  Future<bool> crateApiPgpAppIsStub({
    required PgpApp that,
    required String fingerprint,
  });

  Stream<PgpCertWithIds> crateApiPgpAppIterCerts({required PgpApp that});

  Stream<PgpCertWithIds> crateApiPgpAppIterCertsSearch({
    required PgpApp that,
    required String pattern,
  });

  Stream<PgpCertWithIds> crateApiPgpAppIterCertsSearchKeyid({
    required PgpApp that,
    required String pattern,
  });

  Stream<String> crateApiPgpAppIterFingerprints({required PgpApp that});

  Future<List<CertSynopsis>> crateApiPgpAppLookupSynopses({
    required PgpApp that,
    required KeyHandle kh,
  });

  Future<List<(String, UserId)>> crateApiPgpAppLookupSynopsesByEmail({
    required PgpApp that,
    required String email,
  });

  Future<List<String>> crateApiPgpAppLookupSynopsesByUserid({
    required PgpApp that,
    required UserId userid,
  });

  Future<CertSynopsis> crateApiPgpAppLookupSynopsisByFpr({
    required PgpApp that,
    required UserHandle fingerprint,
  });

  Future<void> crateApiPgpAppMegaFlush({required PgpApp that});

  StoreNetwork crateApiPgpAppNetworkFromFingerprints({
    required PgpApp that,
    required List<String> fingerprints,
  });

  Future<void> crateApiPgpAppSignWithTrustLevel({
    required PgpApp that,
    required String signer,
    required String signee,
    required int level,
    required TrustLevel trust,
  });

  Future<List<CertSynopsis>> crateApiPgpAppSynopses({required PgpApp that});

  Future<List<Certification>> crateApiPgpAppThirdPartyCertificationsOf({
    required PgpApp that,
    required String fpr,
  });

  StoreNetwork crateApiPgpAppUnrootedNetwork({required PgpApp that});

  Future<void> crateApiPgpAppUpdateCert({
    required PgpApp that,
    required ArcLazyCert cert,
  });

  Future<void> crateApiPgpAppUpdateRole({
    required PgpApp that,
    required UserHandle fingerprint,
    required String role,
  });

  Future<void> crateApiPgpAppUploadToKeyserver({
    required PgpApp that,
    required UserHandle fingerprint,
    required String server,
  });

  Future<VerifyResult> crateApiPgpAppVerifyQrAllCerts({
    required PgpApp that,
    required List<int> content,
  });

  Future<void> crateApiDbStorePgpDataCertDelete({
    required PgpDataCert that,
    required SqliteDb conn,
  });

  Future<bool> crateApiDbStorePgpDataCertHasParams();

  Future<void> crateApiDbStorePgpDataCertInsert({
    required PgpDataCert that,
    required SqliteDb conn,
  });

  Future<void> crateApiDbStorePgpDataCertInsertOnConflict({
    required PgpDataCert that,
    required SqliteDb conn,
    required OnConflict onConflict,
  });

  Future<bool> crateApiDbStorePgpDataCertIsEntity();

  Future<void> crateApiDbStorePgpDataCertUpdate({
    required PgpDataCert that,
    required SqliteDb conn,
  });

  Future<void> crateApiPgpImportPgpImportBytesAccept({
    required PgpImportBytes that,
    required List<int> bytes,
  });

  Future<ResultCertParser> crateApiPgpImportPgpImportBytesGetPackets({
    required PgpImportBytes that,
  });

  PgpImportBytes crateApiPgpImportPgpImportBytesNew();

  Future<ResultCertParser> crateApiPgpImportPgpImportFileGetPackets({
    required PgpImportFile that,
  });

  PgpImportFile crateApiPgpImportPgpImportFileNew({required String path});

  Future<WotGraph> crateApiPgpWotNetworkSharedNetworkAuthenticate({
    required SharedNetwork that,
    required String remote,
    required BigInt trust,
  });

  Future<WotGraph> crateApiPgpWotNetworkSharedNetworkDumpAll({
    required SharedNetwork that,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbAllCerts({
    required SqliteDb that,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbAllOwnedCerts({
    required SqliteDb that,
  });

  Future<bool> crateApiDbConnectionSqliteDbCheckOnline({
    required SqliteDb that,
    required String fingerprint,
  });

  Future<void> crateApiDbConnectionSqliteDbClearRole({
    required SqliteDb that,
    required String role,
  });

  Future<void> crateApiDbConnectionSqliteDbDeleteByFingerprint({
    required SqliteDb that,
    required String fingerprint,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByDomain({
    required SqliteDb that,
    required String domain,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByEmail({
    required SqliteDb that,
    required String email,
  });

  Future<PgpDataCert> crateApiDbConnectionSqliteDbGetByFingerprint({
    required SqliteDb that,
    required String fingerprint,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetById({
    required SqliteDb that,
    required String keyId,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByUserid({
    required SqliteDb that,
    required String userid,
  });

  Future<void> crateApiDbConnectionSqliteDbGetConnection({
    required SqliteDb that,
  });

  Future<OnlyFingerprint?> crateApiDbConnectionSqliteDbGetFingerprintForRole({
    required SqliteDb that,
    required String role,
  });

  Watcher crateApiDbConnectionSqliteDbGetWatcher({required SqliteDb that});

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmail({
    required SqliteDb that,
    required String email,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmailAnchorEnd({
    required SqliteDb that,
    required String email,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmailAnchorStart({
    required SqliteDb that,
    required String email,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByUserid({
    required SqliteDb that,
    required String userid,
  });

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByUseridAnchorEnd({
    required SqliteDb that,
    required String userid,
  });

  Future<List<PgpDataCert>>
  crateApiDbConnectionSqliteDbGrepByUseridAnchorStart({
    required SqliteDb that,
    required String userid,
  });

  Future<void> crateApiDbConnectionSqliteDbInsertGroup({
    required SqliteDb that,
    required NewsGroup group,
  });

  Future<OnlyOnline?> crateApiDbConnectionSqliteDbIsOnline({
    required SqliteDb that,
    required String fingerprint,
  });

  SqliteDb crateApiDbConnectionSqliteDbNew({required String path});

  SqliteDb crateApiDbConnectionSqliteDbNewInMemory();

  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbSearchOwnedCerts({
    required SqliteDb that,
    required String userid,
  });

  Future<List<NewsGroup>> crateApiDbConnectionSqliteDbTest({
    required SqliteDb that,
    required UuidValue uuid,
  });

  Future<NewsGroup?> crateApiDbConnectionSqliteDbTestNullable({
    required SqliteDb that,
  });

  Future<NewsGroup> crateApiDbConnectionSqliteDbTestOne({
    required SqliteDb that,
  });

  Future<void> crateApiDbConnectionSqliteDbUpdateRole({
    required SqliteDb that,
    required String fingerprint,
    required String role,
  });

  Future<WotGraph> crateApiPgpWotNetworkStoreNetworkAuthenticate({
    required StoreNetwork that,
    required String remote,
    required BigInt trust,
  });

  Future<WotGraph> crateApiPgpWotNetworkStoreNetworkDumpAll({
    required StoreNetwork that,
  });

  String crateApiPgpUserHandleComposite({required UserHandle that});

  String crateApiPgpUserHandleCompositeLujvo({
    required UserHandle that,
    required bool short,
  });

  String crateApiPgpUserHandleCompositeLujvoOrElse({
    required UserHandle that,
    required bool short,
  });

  UserHandle crateApiPgpUserHandleFromHex({required String hex});

  String crateApiPgpUserHandleName({required UserHandle that});

  VisualKey crateApiPgpUserHandleSeparate({required UserHandle that});

  VisualKey crateApiPgpUserHandleSeparateLujvo({required UserHandle that});

  void crateApiDbConnectionWatcherWatch({
    required Watcher that,
    required String table,
    required FutureOr<void> Function(SqliteDb) cb,
  });

  Config crateApiConfigNew({
    required String keystorePath,
    required String dbPath,
  });

  Future<void> crateApiInitLogging();

  Future<void> crateApiDbStoreOnlyFingerprintDelete({
    required OnlyFingerprint that,
    required SqliteDb conn,
  });

  Future<bool> crateApiDbStoreOnlyFingerprintHasParams();

  Future<void> crateApiDbStoreOnlyFingerprintInsert({
    required OnlyFingerprint that,
    required SqliteDb conn,
  });

  Future<void> crateApiDbStoreOnlyFingerprintInsertOnConflict({
    required OnlyFingerprint that,
    required SqliteDb conn,
    required OnConflict onConflict,
  });

  Future<bool> crateApiDbStoreOnlyFingerprintIsEntity();

  Future<void> crateApiDbStoreOnlyFingerprintUpdate({
    required OnlyFingerprint that,
    required SqliteDb conn,
  });

  Future<void> crateApiDbStoreOnlyOnlineDelete({
    required OnlyOnline that,
    required SqliteDb conn,
  });

  Future<bool> crateApiDbStoreOnlyOnlineHasParams();

  Future<void> crateApiDbStoreOnlyOnlineInsert({
    required OnlyOnline that,
    required SqliteDb conn,
  });

  Future<void> crateApiDbStoreOnlyOnlineInsertOnConflict({
    required OnlyOnline that,
    required SqliteDb conn,
    required OnConflict onConflict,
  });

  Future<bool> crateApiDbStoreOnlyOnlineIsEntity();

  Future<void> crateApiDbStoreOnlyOnlineUpdate({
    required OnlyOnline that,
    required SqliteDb conn,
  });

  PgpCertStubSigs crateApiPgpCertPgpCertStubSigsFromBytes({
    required List<int> bytes,
  });

  PgpCertWithIds crateApiPgpCertPgpCertWithIdsFromBytes({
    required List<int> bytes,
  });

  bool crateApiPgpCertPgpCertWithIdsHasPrivate({required PgpCertWithIds that});

  Future<void> crateApiDbMigrationsRunMigrations({required SqliteDb conn});

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcLazyCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcLazyCert;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ArcLazyCertPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_GenerateCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_GenerateCert;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GenerateCertPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ResultCertParser;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ResultCertParser;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_ResultCertParserPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MaybeCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MaybeCert;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MaybeCertPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_NewsGroup;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_NewsGroup;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NewsGroupPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PathBuf;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PathBuf;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PathBufPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PgpApp;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PgpApp;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PgpAppPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpDataCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpDataCert;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PgpDataCertPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpImportBytes;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpImportBytes;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_PgpImportBytesPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpImportFile;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpImportFile;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_PgpImportFilePtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_SharedNetwork;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_SharedNetwork;

  CrossPlatformFinalizerArg
  get rust_arc_decrement_strong_count_SharedNetworkPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_SqliteDb;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_SqliteDb;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SqliteDbPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_StoreNetwork;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_StoreNetwork;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StoreNetworkPtr;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_UserHandle;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_UserHandle;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UserHandlePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_UserId;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_UserId;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UserIdPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Watcher;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Watcher;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WatcherPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  GenerateCert crateApiPgpKeysGenerateCertComment({
    required GenerateCert that,
    required String comment,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
            that,
            serializer,
          );
          sse_encode_String(comment, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpKeysGenerateCertCommentConstMeta,
        argValues: [that, comment],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpKeysGenerateCertCommentConstMeta =>
      const TaskConstMeta(
        debugName: "GenerateCert_comment",
        argNames: ["that", "comment"],
      );

  @override
  Future<PgpCertWithIds> crateApiPgpKeysGenerateCertGenerate({
    required GenerateCert that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpKeysGenerateCertGenerateConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpKeysGenerateCertGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "GenerateCert_generate",
        argNames: ["that"],
      );

  @override
  GenerateCert crateApiPgpKeysGenerateCertName({
    required GenerateCert that,
    required String name,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
            that,
            serializer,
          );
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpKeysGenerateCertNameConstMeta,
        argValues: [that, name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpKeysGenerateCertNameConstMeta =>
      const TaskConstMeta(
        debugName: "GenerateCert_name",
        argNames: ["that", "name"],
      );

  @override
  GenerateCert crateApiPgpKeysGenerateCertOnline({
    required GenerateCert that,
    required bool online,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
            that,
            serializer,
          );
          sse_encode_bool(online, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpKeysGenerateCertOnlineConstMeta,
        argValues: [that, online],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpKeysGenerateCertOnlineConstMeta =>
      const TaskConstMeta(
        debugName: "GenerateCert_online",
        argNames: ["that", "online"],
      );

  @override
  UserHandle crateApiPgpCertMaybeCertFingerprint({required MaybeCert that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpCertMaybeCertFingerprintConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpCertMaybeCertFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "MaybeCert_fingerprint",
        argNames: ["that"],
      );

  @override
  List<String>? crateApiPgpCertMaybeCertMaybeIds({required MaybeCert that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpCertMaybeCertMaybeIdsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpCertMaybeCertMaybeIdsConstMeta =>
      const TaskConstMeta(debugName: "MaybeCert_maybe_ids", argNames: ["that"]);

  @override
  String crateApiDbEntitiesNewsGroupAutoAccessorGetDescription({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorGetDescriptionConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorGetDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_description",
        argNames: ["that"],
      );

  @override
  String crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorGetGroupNameConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorGetGroupNameConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_group_name",
        argNames: ["that"],
      );

  @override
  UuidValue? crateApiDbEntitiesNewsGroupAutoAccessorGetParent({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_Uuid,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_parent",
        argNames: ["that"],
      );

  @override
  Uint8List? crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentHashConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentHashConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_parent_hash",
        argNames: ["that"],
      );

  @override
  bool crateApiDbEntitiesNewsGroupAutoAccessorGetSent({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetSentConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorGetSentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_sent",
        argNames: ["that"],
      );

  @override
  UuidValue crateApiDbEntitiesNewsGroupAutoAccessorGetUuid({
    required NewsGroup that,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_Uuid,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetUuidConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorGetUuidConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_uuid",
        argNames: ["that"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetDescription({
    required NewsGroup that,
    required String description,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_String(description, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorSetDescriptionConstMeta,
        argValues: [that, description],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorSetDescriptionConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_description",
        argNames: ["that", "description"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName({
    required NewsGroup that,
    required String groupName,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_String(groupName, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorSetGroupNameConstMeta,
        argValues: [that, groupName],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorSetGroupNameConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_group_name",
        argNames: ["that", "groupName"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetParent({
    required NewsGroup that,
    UuidValue? parent,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_opt_Uuid(parent, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentConstMeta,
        argValues: [that, parent],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_parent",
        argNames: ["that", "parent"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash({
    required NewsGroup that,
    Uint8List? parentHash,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_opt_list_prim_u_8_strict(parentHash, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentHashConstMeta,
        argValues: [that, parentHash],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentHashConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_parent_hash",
        argNames: ["that", "parentHash"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetSent({
    required NewsGroup that,
    required bool sent,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_bool(sent, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetSentConstMeta,
        argValues: [that, sent],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorSetSentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_sent",
        argNames: ["that", "sent"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetUuid({
    required NewsGroup that,
    required UuidValue uuid,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_Uuid(uuid, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetUuidConstMeta,
        argValues: [that, uuid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorSetUuidConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_uuid",
        argNames: ["that", "uuid"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupDelete({
    required NewsGroup that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupDeleteConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesNewsGroupHasParams() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 20,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupHasParamsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupHasParamsConstMeta =>
      const TaskConstMeta(debugName: "NewsGroup_has_params", argNames: []);

  @override
  Future<void> crateApiDbEntitiesNewsGroupInsert({
    required NewsGroup that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 21,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupInsertConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupInsertConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupInsertOnConflict({
    required NewsGroup that,
    required SqliteDb conn,
    required OnConflict onConflict,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          sse_encode_on_conflict(onConflict, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 22,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupInsertOnConflictConstMeta,
        argValues: [that, conn, onConflict],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbEntitiesNewsGroupIsEntity() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupIsEntityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupIsEntityConstMeta =>
      const TaskConstMeta(debugName: "NewsGroup_is_entity", argNames: []);

  @override
  Future<void> crateApiDbEntitiesNewsGroupUpdate({
    required NewsGroup that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 24,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbEntitiesNewsGroupUpdateConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<List<PgpCertWithIds>> crateApiPgpAppAllOwnedCerts({
    required PgpApp that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 25,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppAllOwnedCertsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppAllOwnedCertsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_all_owned_certs",
        argNames: ["that"],
      );

  @override
  Future<List<CertificationSet>> crateApiPgpAppCertificationsOf({
    required PgpApp that,
    required String target,
    BigInt? minDepth,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(target, serializer);
          sse_encode_opt_box_autoadd_usize(minDepth, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_certification_set,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppCertificationsOfConstMeta,
        argValues: [that, target, minDepth],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppCertificationsOfConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_certifications_of",
        argNames: ["that", "target", "minDepth"],
      );

  @override
  Future<List<(String, UserId)>> crateApiPgpAppCertifiedUserids({
    required PgpApp that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppCertifiedUseridsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppCertifiedUseridsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_certified_userids",
        argNames: ["that"],
      );

  @override
  Future<List<UserId>> crateApiPgpAppCertifiedUseridsOf({
    required PgpApp that,
    required String fpr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(fpr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 28,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppCertifiedUseridsOfConstMeta,
        argValues: [that, fpr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppCertifiedUseridsOfConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_certified_userids_of",
        argNames: ["that", "fpr"],
      );

  @override
  Future<PgpApp> crateApiPgpAppCreate({required Config config}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_config(config, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppCreateConstMeta,
        argValues: [config],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppCreateConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_create", argNames: ["config"]);

  @override
  Future<void> crateApiPgpAppDeleteCert({
    required PgpApp that,
    required UserHandle fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 30,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppDeleteCertConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppDeleteCertConstMeta => const TaskConstMeta(
    debugName: "PgpApp_delete_cert",
    argNames: ["that", "fingerprint"],
  );

  @override
  Future<void> crateApiPgpAppDeletePrivateKey({
    required PgpApp that,
    required UserHandle fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppDeletePrivateKeyConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppDeletePrivateKeyConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_delete_private_key",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<String> crateApiPgpAppExportArmor({required PgpApp that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppExportArmorConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppExportArmorConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_export_armor", argNames: ["that"]);

  @override
  Future<void> crateApiPgpAppExportFile({
    required PgpApp that,
    required String file,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(file, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppExportFileConstMeta,
        argValues: [that, file],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppExportFileConstMeta => const TaskConstMeta(
    debugName: "PgpApp_export_file",
    argNames: ["that", "file"],
  );

  @override
  Future<void> crateApiPgpAppFillFromKeyserver({
    required PgpApp that,
    required UserHandle fingerprint,
    required String server,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          sse_encode_String(server, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 34,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppFillFromKeyserverConstMeta,
        argValues: [that, fingerprint, server],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppFillFromKeyserverConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_fill_from_keyserver",
        argNames: ["that", "fingerprint", "server"],
      );

  @override
  GenerateCert crateApiPgpAppGenerateKey({
    required PgpApp that,
    required String email,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppGenerateKeyConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGenerateKeyConstMeta => const TaskConstMeta(
    debugName: "PgpApp_generate_key",
    argNames: ["that", "email"],
  );

  @override
  Future<PgpCertWithIds?> crateApiPgpAppGetCertByRole({
    required PgpApp that,
    required String role,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(role, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppGetCertByRoleConstMeta,
        argValues: [that, role],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetCertByRoleConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_get_cert_by_role",
        argNames: ["that", "role"],
      );

  @override
  SqliteDb crateApiPgpAppGetDb({required PgpApp that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppGetDbConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetDbConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_get_db", argNames: ["that"]);

  @override
  Future<List<String>> crateApiPgpAppGetFingerprints({required PgpApp that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 38,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppGetFingerprintsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetFingerprintsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_get_fingerprints",
        argNames: ["that"],
      );

  @override
  Future<PgpCertWithIds> crateApiPgpAppGetKeyFromFingerprint({
    required PgpApp that,
    required UserHandle fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 39,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppGetKeyFromFingerprintConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetKeyFromFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_get_key_from_fingerprint",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<Uint8List> crateApiPgpAppGetQr({
    required PgpApp that,
    required String resource,
    String? handle,
    String? description,
    required UserHandle key,
    required bool fullKey,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(resource, serializer);
          sse_encode_opt_String(handle, serializer);
          sse_encode_opt_String(description, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            key,
            serializer,
          );
          sse_encode_bool(fullKey, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 40,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppGetQrConstMeta,
        argValues: [that, resource, handle, description, key, fullKey],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetQrConstMeta => const TaskConstMeta(
    debugName: "PgpApp_get_qr",
    argNames: ["that", "resource", "handle", "description", "key", "fullKey"],
  );

  @override
  Future<PgpCertWithIds> crateApiPgpAppGetStubFromFingerprint({
    required PgpApp that,
    required UserHandle fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 41,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppGetStubFromFingerprintConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetStubFromFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_get_stub_from_fingerprint",
        argNames: ["that", "fingerprint"],
      );

  @override
  Watcher crateApiPgpAppGetWatcher({required PgpApp that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppGetWatcherConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppGetWatcherConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_get_watcher", argNames: ["that"]);

  @override
  Future<void> crateApiPgpAppImportCerts({
    required PgpApp that,
    required PgpImport import_,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_DynTrait_PgpImport(import_, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 43,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppImportCertsConstMeta,
        argValues: [that, import_],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppImportCertsConstMeta => const TaskConstMeta(
    debugName: "PgpApp_import_certs",
    argNames: ["that", "import_"],
  );

  @override
  Future<bool> crateApiPgpAppIsStub({
    required PgpApp that,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 44,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppIsStubConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppIsStubConstMeta => const TaskConstMeta(
    debugName: "PgpApp_is_stub",
    argNames: ["that", "fingerprint"],
  );

  @override
  Stream<PgpCertWithIds> crateApiPgpAppIterCerts({required PgpApp that}) {
    final sink = RustStreamSink<PgpCertWithIds>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
              that,
              serializer,
            );
            sse_encode_StreamSink_pgp_cert_with_ids_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 45,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPgpAppIterCertsConstMeta,
          argValues: [that, sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPgpAppIterCertsConstMeta => const TaskConstMeta(
    debugName: "PgpApp_iter_certs",
    argNames: ["that", "sink"],
  );

  @override
  Stream<PgpCertWithIds> crateApiPgpAppIterCertsSearch({
    required PgpApp that,
    required String pattern,
  }) {
    final sink = RustStreamSink<PgpCertWithIds>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
              that,
              serializer,
            );
            sse_encode_StreamSink_pgp_cert_with_ids_Sse(sink, serializer);
            sse_encode_String(pattern, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 46,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPgpAppIterCertsSearchConstMeta,
          argValues: [that, sink, pattern],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPgpAppIterCertsSearchConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_iter_certs_search",
        argNames: ["that", "sink", "pattern"],
      );

  @override
  Stream<PgpCertWithIds> crateApiPgpAppIterCertsSearchKeyid({
    required PgpApp that,
    required String pattern,
  }) {
    final sink = RustStreamSink<PgpCertWithIds>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
              that,
              serializer,
            );
            sse_encode_StreamSink_pgp_cert_with_ids_Sse(sink, serializer);
            sse_encode_String(pattern, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 47,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPgpAppIterCertsSearchKeyidConstMeta,
          argValues: [that, sink, pattern],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPgpAppIterCertsSearchKeyidConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_iter_certs_search_keyid",
        argNames: ["that", "sink", "pattern"],
      );

  @override
  Stream<String> crateApiPgpAppIterFingerprints({required PgpApp that}) {
    final sink = RustStreamSink<String>();
    unawaited(
      handler.executeNormal(
        NormalTask(
          callFfi: (port_) {
            final serializer = SseSerializer(generalizedFrbRustBinding);
            sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
              that,
              serializer,
            );
            sse_encode_StreamSink_String_Sse(sink, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 48,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateApiPgpAppIterFingerprintsConstMeta,
          argValues: [that, sink],
          apiImpl: this,
        ),
      ),
    );
    return sink.stream;
  }

  TaskConstMeta get kCrateApiPgpAppIterFingerprintsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_iter_fingerprints",
        argNames: ["that", "sink"],
      );

  @override
  Future<List<CertSynopsis>> crateApiPgpAppLookupSynopses({
    required PgpApp that,
    required KeyHandle kh,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_box_autoadd_key_handle(kh, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 49,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_cert_synopsis,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppLookupSynopsesConstMeta,
        argValues: [that, kh],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppLookupSynopsesConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_lookup_synopses",
        argNames: ["that", "kh"],
      );

  @override
  Future<List<(String, UserId)>> crateApiPgpAppLookupSynopsesByEmail({
    required PgpApp that,
    required String email,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 50,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppLookupSynopsesByEmailConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppLookupSynopsesByEmailConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_lookup_synopses_by_email",
        argNames: ["that", "email"],
      );

  @override
  Future<List<String>> crateApiPgpAppLookupSynopsesByUserid({
    required PgpApp that,
    required UserId userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
            userid,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 51,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppLookupSynopsesByUseridConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppLookupSynopsesByUseridConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_lookup_synopses_by_userid",
        argNames: ["that", "userid"],
      );

  @override
  Future<CertSynopsis> crateApiPgpAppLookupSynopsisByFpr({
    required PgpApp that,
    required UserHandle fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 52,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cert_synopsis,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppLookupSynopsisByFprConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppLookupSynopsisByFprConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_lookup_synopsis_by_fpr",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<void> crateApiPgpAppMegaFlush({required PgpApp that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 53,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppMegaFlushConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppMegaFlushConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_mega_flush", argNames: ["that"]);

  @override
  StoreNetwork crateApiPgpAppNetworkFromFingerprints({
    required PgpApp that,
    required List<String> fingerprints,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_list_String(fingerprints, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppNetworkFromFingerprintsConstMeta,
        argValues: [that, fingerprints],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppNetworkFromFingerprintsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_network_from_fingerprints",
        argNames: ["that", "fingerprints"],
      );

  @override
  Future<void> crateApiPgpAppSignWithTrustLevel({
    required PgpApp that,
    required String signer,
    required String signee,
    required int level,
    required TrustLevel trust,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(signer, serializer);
          sse_encode_String(signee, serializer);
          sse_encode_u_8(level, serializer);
          sse_encode_box_autoadd_trust_level(trust, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 55,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppSignWithTrustLevelConstMeta,
        argValues: [that, signer, signee, level, trust],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppSignWithTrustLevelConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_sign_with_trust_level",
        argNames: ["that", "signer", "signee", "level", "trust"],
      );

  @override
  Future<List<CertSynopsis>> crateApiPgpAppSynopses({required PgpApp that}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 56,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_cert_synopsis,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpAppSynopsesConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppSynopsesConstMeta =>
      const TaskConstMeta(debugName: "PgpApp_synopses", argNames: ["that"]);

  @override
  Future<List<Certification>> crateApiPgpAppThirdPartyCertificationsOf({
    required PgpApp that,
    required String fpr,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_String(fpr, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 57,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_certification,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppThirdPartyCertificationsOfConstMeta,
        argValues: [that, fpr],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppThirdPartyCertificationsOfConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_third_party_certifications_of",
        argNames: ["that", "fpr"],
      );

  @override
  StoreNetwork crateApiPgpAppUnrootedNetwork({required PgpApp that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppUnrootedNetworkConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppUnrootedNetworkConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_unrooted_network",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiPgpAppUpdateCert({
    required PgpApp that,
    required ArcLazyCert cert,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
            cert,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 59,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppUpdateCertConstMeta,
        argValues: [that, cert],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppUpdateCertConstMeta => const TaskConstMeta(
    debugName: "PgpApp_update_cert",
    argNames: ["that", "cert"],
  );

  @override
  Future<void> crateApiPgpAppUpdateRole({
    required PgpApp that,
    required UserHandle fingerprint,
    required String role,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          sse_encode_String(role, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 60,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppUpdateRoleConstMeta,
        argValues: [that, fingerprint, role],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppUpdateRoleConstMeta => const TaskConstMeta(
    debugName: "PgpApp_update_role",
    argNames: ["that", "fingerprint", "role"],
  );

  @override
  Future<void> crateApiPgpAppUploadToKeyserver({
    required PgpApp that,
    required UserHandle fingerprint,
    required String server,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            fingerprint,
            serializer,
          );
          sse_encode_String(server, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 61,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppUploadToKeyserverConstMeta,
        argValues: [that, fingerprint, server],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppUploadToKeyserverConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_upload_to_keyserver",
        argNames: ["that", "fingerprint", "server"],
      );

  @override
  Future<VerifyResult> crateApiPgpAppVerifyQrAllCerts({
    required PgpApp that,
    required List<int> content,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(content, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 62,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_verify_result,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpAppVerifyQrAllCertsConstMeta,
        argValues: [that, content],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpAppVerifyQrAllCertsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpApp_verify_qr_all_certs",
        argNames: ["that", "content"],
      );

  @override
  Future<void> crateApiDbStorePgpDataCertDelete({
    required PgpDataCert that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 63,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStorePgpDataCertDeleteConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "PgpDataCert_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbStorePgpDataCertHasParams() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 64,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStorePgpDataCertHasParamsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertHasParamsConstMeta =>
      const TaskConstMeta(debugName: "PgpDataCert_has_params", argNames: []);

  @override
  Future<void> crateApiDbStorePgpDataCertInsert({
    required PgpDataCert that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 65,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStorePgpDataCertInsertConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertInsertConstMeta =>
      const TaskConstMeta(
        debugName: "PgpDataCert_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbStorePgpDataCertInsertOnConflict({
    required PgpDataCert that,
    required SqliteDb conn,
    required OnConflict onConflict,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          sse_encode_on_conflict(onConflict, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 66,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStorePgpDataCertInsertOnConflictConstMeta,
        argValues: [that, conn, onConflict],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "PgpDataCert_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbStorePgpDataCertIsEntity() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 67,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStorePgpDataCertIsEntityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertIsEntityConstMeta =>
      const TaskConstMeta(debugName: "PgpDataCert_is_entity", argNames: []);

  @override
  Future<void> crateApiDbStorePgpDataCertUpdate({
    required PgpDataCert that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 68,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStorePgpDataCertUpdateConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStorePgpDataCertUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "PgpDataCert_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiPgpImportPgpImportBytesAccept({
    required PgpImportBytes that,
    required List<int> bytes,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
            that,
            serializer,
          );
          sse_encode_list_prim_u_8_loose(bytes, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 69,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpImportPgpImportBytesAcceptConstMeta,
        argValues: [that, bytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpImportPgpImportBytesAcceptConstMeta =>
      const TaskConstMeta(
        debugName: "PgpImportBytes_accept",
        argNames: ["that", "bytes"],
      );

  @override
  Future<ResultCertParser> crateApiPgpImportPgpImportBytesGetPackets({
    required PgpImportBytes that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 70,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Lifetimeable_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultCertParserstatic,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpImportPgpImportBytesGetPacketsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpImportPgpImportBytesGetPacketsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpImportBytes_get_packets",
        argNames: ["that"],
      );

  @override
  PgpImportBytes crateApiPgpImportPgpImportBytesNew() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpImportPgpImportBytesNewConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpImportPgpImportBytesNewConstMeta =>
      const TaskConstMeta(debugName: "PgpImportBytes_new", argNames: []);

  @override
  Future<ResultCertParser> crateApiPgpImportPgpImportFileGetPackets({
    required PgpImportFile that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 72,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Lifetimeable_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultCertParserstatic,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpImportPgpImportFileGetPacketsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpImportPgpImportFileGetPacketsConstMeta =>
      const TaskConstMeta(
        debugName: "PgpImportFile_get_packets",
        argNames: ["that"],
      );

  @override
  PgpImportFile crateApiPgpImportPgpImportFileNew({required String path}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpImportPgpImportFileNewConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpImportPgpImportFileNewConstMeta =>
      const TaskConstMeta(debugName: "PgpImportFile_new", argNames: ["path"]);

  @override
  Future<WotGraph> crateApiPgpWotNetworkSharedNetworkAuthenticate({
    required SharedNetwork that,
    required String remote,
    required BigInt trust,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
            that,
            serializer,
          );
          sse_encode_String(remote, serializer);
          sse_encode_usize(trust, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 74,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wot_graph,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpWotNetworkSharedNetworkAuthenticateConstMeta,
        argValues: [that, remote, trust],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpWotNetworkSharedNetworkAuthenticateConstMeta =>
      const TaskConstMeta(
        debugName: "SharedNetwork_authenticate",
        argNames: ["that", "remote", "trust"],
      );

  @override
  Future<WotGraph> crateApiPgpWotNetworkSharedNetworkDumpAll({
    required SharedNetwork that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 75,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wot_graph,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpWotNetworkSharedNetworkDumpAllConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpWotNetworkSharedNetworkDumpAllConstMeta =>
      const TaskConstMeta(
        debugName: "SharedNetwork_dump_all",
        argNames: ["that"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbAllCerts({
    required SqliteDb that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 76,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbAllCertsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbAllCertsConstMeta =>
      const TaskConstMeta(debugName: "SqliteDb_all_certs", argNames: ["that"]);

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbAllOwnedCerts({
    required SqliteDb that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 77,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbAllOwnedCertsConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbAllOwnedCertsConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_all_owned_certs",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiDbConnectionSqliteDbCheckOnline({
    required SqliteDb that,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 78,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbCheckOnlineConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbCheckOnlineConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_check_online",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<void> crateApiDbConnectionSqliteDbClearRole({
    required SqliteDb that,
    required String role,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(role, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 79,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbClearRoleConstMeta,
        argValues: [that, role],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbClearRoleConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_clear_role",
        argNames: ["that", "role"],
      );

  @override
  Future<void> crateApiDbConnectionSqliteDbDeleteByFingerprint({
    required SqliteDb that,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 80,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbDeleteByFingerprintConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbDeleteByFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_delete_by_fingerprint",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByDomain({
    required SqliteDb that,
    required String domain,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(domain, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 81,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetByDomainConstMeta,
        argValues: [that, domain],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetByDomainConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_by_domain",
        argNames: ["that", "domain"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByEmail({
    required SqliteDb that,
    required String email,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 82,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetByEmailConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetByEmailConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_by_email",
        argNames: ["that", "email"],
      );

  @override
  Future<PgpDataCert> crateApiDbConnectionSqliteDbGetByFingerprint({
    required SqliteDb that,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 83,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetByFingerprintConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetByFingerprintConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_by_fingerprint",
        argNames: ["that", "fingerprint"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetById({
    required SqliteDb that,
    required String keyId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(keyId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 84,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetByIdConstMeta,
        argValues: [that, keyId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetByIdConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_by_id",
        argNames: ["that", "keyId"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGetByUserid({
    required SqliteDb that,
    required String userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(userid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 85,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetByUseridConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetByUseridConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_by_userid",
        argNames: ["that", "userid"],
      );

  @override
  Future<void> crateApiDbConnectionSqliteDbGetConnection({
    required SqliteDb that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 86,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetConnectionConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_connection",
        argNames: ["that"],
      );

  @override
  Future<OnlyFingerprint?> crateApiDbConnectionSqliteDbGetFingerprintForRole({
    required SqliteDb that,
    required String role,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(role, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 87,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_only_fingerprint,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetFingerprintForRoleConstMeta,
        argValues: [that, role],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbConnectionSqliteDbGetFingerprintForRoleConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_fingerprint_for_role",
        argNames: ["that", "role"],
      );

  @override
  Watcher crateApiDbConnectionSqliteDbGetWatcher({required SqliteDb that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 88)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGetWatcherConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGetWatcherConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_get_watcher",
        argNames: ["that"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmail({
    required SqliteDb that,
    required String email,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 89,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGrepByEmailConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGrepByEmailConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_email",
        argNames: ["that", "email"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmailAnchorEnd({
    required SqliteDb that,
    required String email,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 90,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGrepByEmailAnchorEndConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbConnectionSqliteDbGrepByEmailAnchorEndConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_email_anchor_end",
        argNames: ["that", "email"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByEmailAnchorStart({
    required SqliteDb that,
    required String email,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(email, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 91,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGrepByEmailAnchorStartConstMeta,
        argValues: [that, email],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbConnectionSqliteDbGrepByEmailAnchorStartConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_email_anchor_start",
        argNames: ["that", "email"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByUserid({
    required SqliteDb that,
    required String userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(userid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 92,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGrepByUseridConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbGrepByUseridConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_userid",
        argNames: ["that", "userid"],
      );

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbGrepByUseridAnchorEnd({
    required SqliteDb that,
    required String userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(userid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 93,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbGrepByUseridAnchorEndConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbConnectionSqliteDbGrepByUseridAnchorEndConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_userid_anchor_end",
        argNames: ["that", "userid"],
      );

  @override
  Future<List<PgpDataCert>>
  crateApiDbConnectionSqliteDbGrepByUseridAnchorStart({
    required SqliteDb that,
    required String userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(userid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 94,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta:
            kCrateApiDbConnectionSqliteDbGrepByUseridAnchorStartConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiDbConnectionSqliteDbGrepByUseridAnchorStartConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_grep_by_userid_anchor_start",
        argNames: ["that", "userid"],
      );

  @override
  Future<void> crateApiDbConnectionSqliteDbInsertGroup({
    required SqliteDb that,
    required NewsGroup group,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            group,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 95,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbInsertGroupConstMeta,
        argValues: [that, group],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbInsertGroupConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_insert_group",
        argNames: ["that", "group"],
      );

  @override
  Future<OnlyOnline?> crateApiDbConnectionSqliteDbIsOnline({
    required SqliteDb that,
    required String fingerprint,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 96,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_only_online,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbIsOnlineConstMeta,
        argValues: [that, fingerprint],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbIsOnlineConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_is_online",
        argNames: ["that", "fingerprint"],
      );

  @override
  SqliteDb crateApiDbConnectionSqliteDbNew({required String path}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(path, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbNewConstMeta,
        argValues: [path],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbNewConstMeta =>
      const TaskConstMeta(debugName: "SqliteDb_new", argNames: ["path"]);

  @override
  SqliteDb crateApiDbConnectionSqliteDbNewInMemory() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98)!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbNewInMemoryConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbNewInMemoryConstMeta =>
      const TaskConstMeta(debugName: "SqliteDb_new_in_memory", argNames: []);

  @override
  Future<List<PgpDataCert>> crateApiDbConnectionSqliteDbSearchOwnedCerts({
    required SqliteDb that,
    required String userid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(userid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 99,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbSearchOwnedCertsConstMeta,
        argValues: [that, userid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbSearchOwnedCertsConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_search_owned_certs",
        argNames: ["that", "userid"],
      );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSqliteDbTest({
    required SqliteDb that,
    required UuidValue uuid,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_Uuid(uuid, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 100,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbTestConstMeta,
        argValues: [that, uuid],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbTestConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_test",
        argNames: ["that", "uuid"],
      );

  @override
  Future<NewsGroup?> crateApiDbConnectionSqliteDbTestNullable({
    required SqliteDb that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 101,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbTestNullableConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbTestNullableConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_test_nullable",
        argNames: ["that"],
      );

  @override
  Future<NewsGroup> crateApiDbConnectionSqliteDbTestOne({
    required SqliteDb that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 102,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbTestOneConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbTestOneConstMeta =>
      const TaskConstMeta(debugName: "SqliteDb_test_one", argNames: ["that"]);

  @override
  Future<void> crateApiDbConnectionSqliteDbUpdateRole({
    required SqliteDb that,
    required String fingerprint,
    required String role,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            that,
            serializer,
          );
          sse_encode_String(fingerprint, serializer);
          sse_encode_String(role, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 103,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbConnectionSqliteDbUpdateRoleConstMeta,
        argValues: [that, fingerprint, role],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionSqliteDbUpdateRoleConstMeta =>
      const TaskConstMeta(
        debugName: "SqliteDb_update_role",
        argNames: ["that", "fingerprint", "role"],
      );

  @override
  Future<WotGraph> crateApiPgpWotNetworkStoreNetworkAuthenticate({
    required StoreNetwork that,
    required String remote,
    required BigInt trust,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
            that,
            serializer,
          );
          sse_encode_String(remote, serializer);
          sse_encode_usize(trust, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 104,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wot_graph,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpWotNetworkStoreNetworkAuthenticateConstMeta,
        argValues: [that, remote, trust],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpWotNetworkStoreNetworkAuthenticateConstMeta =>
      const TaskConstMeta(
        debugName: "StoreNetwork_authenticate",
        argNames: ["that", "remote", "trust"],
      );

  @override
  Future<WotGraph> crateApiPgpWotNetworkStoreNetworkDumpAll({
    required StoreNetwork that,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
            that,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 105,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_wot_graph,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpWotNetworkStoreNetworkDumpAllConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpWotNetworkStoreNetworkDumpAllConstMeta =>
      const TaskConstMeta(
        debugName: "StoreNetwork_dump_all",
        argNames: ["that"],
      );

  @override
  String crateApiPgpUserHandleComposite({required UserHandle that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 168,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpUserHandleCompositeConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleCompositeConstMeta =>
      const TaskConstMeta(
        debugName: "UserHandle_composite",
        argNames: ["that"],
      );

  @override
  String crateApiPgpUserHandleCompositeLujvo({
    required UserHandle that,
    required bool short,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          sse_encode_bool(short, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 169,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpUserHandleCompositeLujvoConstMeta,
        argValues: [that, short],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleCompositeLujvoConstMeta =>
      const TaskConstMeta(
        debugName: "UserHandle_composite_lujvo",
        argNames: ["that", "short"],
      );

  @override
  String crateApiPgpUserHandleCompositeLujvoOrElse({
    required UserHandle that,
    required bool short,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          sse_encode_bool(short, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 170,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpUserHandleCompositeLujvoOrElseConstMeta,
        argValues: [that, short],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleCompositeLujvoOrElseConstMeta =>
      const TaskConstMeta(
        debugName: "UserHandle_composite_lujvo_or_else",
        argNames: ["that", "short"],
      );

  @override
  UserHandle crateApiPgpUserHandleFromHex({required String hex}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(hex, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 171,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData:
              sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpUserHandleFromHexConstMeta,
        argValues: [hex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleFromHexConstMeta =>
      const TaskConstMeta(debugName: "UserHandle_from_hex", argNames: ["hex"]);

  @override
  String crateApiPgpUserHandleName({required UserHandle that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 172,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpUserHandleNameConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleNameConstMeta =>
      const TaskConstMeta(debugName: "UserHandle_name", argNames: ["that"]);

  @override
  VisualKey crateApiPgpUserHandleSeparate({required UserHandle that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 173,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_visual_key,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpUserHandleSeparateConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleSeparateConstMeta =>
      const TaskConstMeta(debugName: "UserHandle_separate", argNames: ["that"]);

  @override
  VisualKey crateApiPgpUserHandleSeparateLujvo({required UserHandle that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            that,
            serializer,
          );
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 174,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_visual_key,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpUserHandleSeparateLujvoConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpUserHandleSeparateLujvoConstMeta =>
      const TaskConstMeta(
        debugName: "UserHandle_separate_lujvo",
        argNames: ["that"],
      );

  @override
  void crateApiDbConnectionWatcherWatch({
    required Watcher that,
    required String table,
    required FutureOr<void> Function(SqliteDb) cb,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
            that,
            serializer,
          );
          sse_encode_String(table, serializer);
          sse_encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb_Output_unit_AnyhowException(
            cb,
            serializer,
          );
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 175,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbConnectionWatcherWatchConstMeta,
        argValues: [that, table, cb],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbConnectionWatcherWatchConstMeta =>
      const TaskConstMeta(
        debugName: "Watcher_watch",
        argNames: ["that", "table", "cb"],
      );

  @override
  Config crateApiConfigNew({
    required String keystorePath,
    required String dbPath,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(keystorePath, serializer);
          sse_encode_String(dbPath, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 176,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_config,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiConfigNewConstMeta,
        argValues: [keystorePath, dbPath],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiConfigNewConstMeta => const TaskConstMeta(
    debugName: "config_new",
    argNames: ["keystorePath", "dbPath"],
  );

  @override
  Future<void> crateApiInitLogging() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 178,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiInitLoggingConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiInitLoggingConstMeta =>
      const TaskConstMeta(debugName: "init_logging", argNames: []);

  @override
  Future<void> crateApiDbStoreOnlyFingerprintDelete({
    required OnlyFingerprint that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_fingerprint(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 179,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintDeleteConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbStoreOnlyFingerprintHasParams() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 180,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintHasParamsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_has_params",
        argNames: [],
      );

  @override
  Future<void> crateApiDbStoreOnlyFingerprintInsert({
    required OnlyFingerprint that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_fingerprint(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 181,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintInsertConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintInsertConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbStoreOnlyFingerprintInsertOnConflict({
    required OnlyFingerprint that,
    required SqliteDb conn,
    required OnConflict onConflict,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_fingerprint(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          sse_encode_on_conflict(onConflict, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 182,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintInsertOnConflictConstMeta,
        argValues: [that, conn, onConflict],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbStoreOnlyFingerprintIsEntity() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 183,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintIsEntityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_is_entity",
        argNames: [],
      );

  @override
  Future<void> crateApiDbStoreOnlyFingerprintUpdate({
    required OnlyFingerprint that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_fingerprint(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 184,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyFingerprintUpdateConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyFingerprintUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "only_fingerprint_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbStoreOnlyOnlineDelete({
    required OnlyOnline that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_online(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 185,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineDeleteConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "only_online_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbStoreOnlyOnlineHasParams() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 186,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineHasParamsConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineHasParamsConstMeta =>
      const TaskConstMeta(debugName: "only_online_has_params", argNames: []);

  @override
  Future<void> crateApiDbStoreOnlyOnlineInsert({
    required OnlyOnline that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_online(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 187,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineInsertConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineInsertConstMeta =>
      const TaskConstMeta(
        debugName: "only_online_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbStoreOnlyOnlineInsertOnConflict({
    required OnlyOnline that,
    required SqliteDb conn,
    required OnConflict onConflict,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_online(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          sse_encode_on_conflict(onConflict, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 188,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineInsertOnConflictConstMeta,
        argValues: [that, conn, onConflict],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "only_online_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbStoreOnlyOnlineIsEntity() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 189,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineIsEntityConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineIsEntityConstMeta =>
      const TaskConstMeta(debugName: "only_online_is_entity", argNames: []);

  @override
  Future<void> crateApiDbStoreOnlyOnlineUpdate({
    required OnlyOnline that,
    required SqliteDb conn,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_only_online(that, serializer);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 190,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbStoreOnlyOnlineUpdateConstMeta,
        argValues: [that, conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbStoreOnlyOnlineUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "only_online_update",
        argNames: ["that", "conn"],
      );

  @override
  PgpCertStubSigs crateApiPgpCertPgpCertStubSigsFromBytes({
    required List<int> bytes,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(bytes, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 191,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_stub_sigs,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpCertPgpCertStubSigsFromBytesConstMeta,
        argValues: [bytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpCertPgpCertStubSigsFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "pgp_cert_stub_sigs_from_bytes",
        argNames: ["bytes"],
      );

  @override
  PgpCertWithIds crateApiPgpCertPgpCertWithIdsFromBytes({
    required List<int> bytes,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(bytes, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 192,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiPgpCertPgpCertWithIdsFromBytesConstMeta,
        argValues: [bytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpCertPgpCertWithIdsFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "pgp_cert_with_ids_from_bytes",
        argNames: ["bytes"],
      );

  @override
  bool crateApiPgpCertPgpCertWithIdsHasPrivate({required PgpCertWithIds that}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_pgp_cert_with_ids(that, serializer);
          return pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 193,
          )!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_bool,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiPgpCertPgpCertWithIdsHasPrivateConstMeta,
        argValues: [that],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPgpCertPgpCertWithIdsHasPrivateConstMeta =>
      const TaskConstMeta(
        debugName: "pgp_cert_with_ids_has_private",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiDbMigrationsRunMigrations({required SqliteDb conn}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            conn,
            serializer,
          );
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 194,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateApiDbMigrationsRunMigrationsConstMeta,
        argValues: [conn],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiDbMigrationsRunMigrationsConstMeta =>
      const TaskConstMeta(debugName: "run_migrations", argNames: ["conn"]);

  Future<void> Function(int, dynamic)
  encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb_Output_unit_AnyhowException(
    FutureOr<void> Function(SqliteDb) raw,
  ) {
    return (callId, rawArg0) async {
      final arg0 =
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
            rawArg0,
          );

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
        callId: callId,
        ptr: output.ptr,
        rustVecLen: output.rustVecLen,
        dataLen: output.dataLen,
      );
    };
  }

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ArcLazyCert => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ArcLazyCert => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_GenerateCert => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_GenerateCert => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_ResultCertParser => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_ResultCertParser => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_MaybeCert => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_MaybeCert => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_NewsGroup => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_NewsGroup => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PathBuf => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PathBuf => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpApp => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpApp => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpDataCert => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpDataCert => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpImportBytes => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpImportBytes => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_PgpImportFile => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_PgpImportFile => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_SharedNetwork => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_SharedNetwork => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_SqliteDb => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_SqliteDb => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_StoreNetwork => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_StoreNetwork => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_UserHandle => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_UserHandle => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_UserId => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_UserId => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID;

  RustArcIncrementStrongCountFnType
  get rust_arc_increment_strong_count_Watcher => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher;

  RustArcDecrementStrongCountFnType
  get rust_arc_decrement_strong_count_Watcher => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ResultCertParser
  dco_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
      raw,
    );
  }

  @protected
  PgpImportBytes
  dco_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
      raw,
    );
  }

  @protected
  PgpImportFile
  dco_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
      raw,
    );
  }

  @protected
  ArcLazyCert
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcLazyCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GenerateCert
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GenerateCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MaybeCert
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MaybeCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PathBuf
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PathBufImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpApp
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpAppImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpDataCert
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportBytes
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportFile
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SharedNetwork
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SqliteDb
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SqliteDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StoreNetwork
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UserHandle
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UserHandleImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UserId
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UserIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
  dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MaybeCert
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MaybeCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpApp
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpAppImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpDataCert
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportBytes
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportFile
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SharedNetwork
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SqliteDb
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SqliteDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StoreNetwork
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UserHandle
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UserHandleImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
  dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<void> Function(SqliteDb)
  dco_decode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb_Output_unit_AnyhowException(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  PgpImport dco_decode_DynTrait_PgpImport(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  ResultCertParser
  dco_decode_Lifetimeable_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultCertParserstatic(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError(
      'Not implemented in this codec, please use the other one',
    );
  }

  @protected
  Map<String, GraphVertex> dco_decode_Map_String_graph_vertex_None(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_graph_vertex(
        raw,
      ).map((e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  ArcLazyCert
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcLazyCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GenerateCert
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GenerateCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ResultCertParser
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResultCertParserImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MaybeCert
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MaybeCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PathBuf
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PathBufImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpApp
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpAppImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpDataCert
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportBytes
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PgpImportFile
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SharedNetwork
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SqliteDb
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SqliteDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StoreNetwork
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UserHandle
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UserHandleImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UserId
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UserIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Set<GraphEdge> dco_decode_Set_graph_edge_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_graph_edge(raw));
  }

  @protected
  RustStreamSink<String> dco_decode_StreamSink_String_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<PgpCertWithIds> dco_decode_StreamSink_pgp_cert_with_ids_Sse(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  CertDao dco_decode_TraitDef_CertDao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  CertNetworkTrait dco_decode_TraitDef_CertNetworkTrait(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  CertStoreTrait dco_decode_TraitDef_CertStoreTrait(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  Crud dco_decode_TraitDef_Crud(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  Dao dco_decode_TraitDef_Dao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  FromRow dco_decode_TraitDef_FromRow(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  GetParams dco_decode_TraitDef_GetParams(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  PgpAppTrait dco_decode_TraitDef_PgpAppTrait(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  PgpImport dco_decode_TraitDef_PgpImport(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  PgpServiceTrait dco_decode_TraitDef_PgpServiceTrait(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  TestDao dco_decode_TraitDef_TestDao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  Verifier dco_decode_TraitDef_Verifier(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  UuidValue dco_decode_Uuid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UuidValue.fromByteList(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  NewsGroup
  dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
      raw,
    );
  }

  @protected
  Config dco_decode_box_autoadd_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config(raw);
  }

  @protected
  KeyHandle dco_decode_box_autoadd_key_handle(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_key_handle(raw);
  }

  @protected
  OnlyFingerprint dco_decode_box_autoadd_only_fingerprint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_only_fingerprint(raw);
  }

  @protected
  OnlyOnline dco_decode_box_autoadd_only_online(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_only_online(raw);
  }

  @protected
  PgpCertWithIds dco_decode_box_autoadd_pgp_cert_with_ids(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pgp_cert_with_ids(raw);
  }

  @protected
  PgpImportImplementor dco_decode_box_autoadd_pgp_import_implementor(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pgp_import_implementor(raw);
  }

  @protected
  QrCodeContent dco_decode_box_autoadd_qr_code_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_qr_code_content(raw);
  }

  @protected
  TrustLevel dco_decode_box_autoadd_trust_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_trust_level(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_usize(raw);
  }

  @protected
  CertSynopsis dco_decode_cert_synopsis(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CertSynopsis(
      fingerprint: dco_decode_String(arr[0]),
      keyid: dco_decode_String(arr[1]),
      keyHandle: dco_decode_key_handle(arr[2]),
      revoked: dco_decode_bool(arr[3]),
      userids: dco_decode_list_String(arr[4]),
    );
  }

  @protected
  Certification dco_decode_certification(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Certification(
      issuer: dco_decode_String(arr[0]),
      target: dco_decode_String(arr[1]),
    );
  }

  @protected
  CertificationSet dco_decode_certification_set(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CertificationSet(
      issuer: dco_decode_String(arr[0]),
      target: dco_decode_String(arr[1]),
      certifications: dco_decode_list_record_opt_string_list_certification(
        arr[2],
      ),
    );
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Config.raw(
      keystorePath:
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
            arr[0],
          ),
      dbPath:
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
            arr[1],
          ),
    );
  }

  @protected
  GraphEdge dco_decode_graph_edge(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GraphEdge(
      srcId: dco_decode_String(arr[0]),
      dstId: dco_decode_String(arr[1]),
      ranking: dco_decode_i_64(arr[2]),
      edgeName: dco_decode_String(arr[3]),
    );
  }

  @protected
  GraphVertex dco_decode_graph_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GraphVertex(
      id: dco_decode_String(arr[0]),
      tag: dco_decode_String(arr[1]),
      tags: dco_decode_list_String(arr[2]),
      data: dco_decode_opt_list_prim_u_8_strict(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  KeyHandle dco_decode_key_handle(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return KeyHandle_KeyId(dco_decode_String(raw[1]));
      case 1:
        return KeyHandle_Fingerprint(dco_decode_String(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<MaybeCert>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert,
        )
        .toList();
  }

  @protected
  List<NewsGroup>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        )
        .toList();
  }

  @protected
  List<PgpDataCert>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert,
        )
        .toList();
  }

  @protected
  List<UserId>
  dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID,
        )
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<CertSynopsis> dco_decode_list_cert_synopsis(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_cert_synopsis).toList();
  }

  @protected
  List<Certification> dco_decode_list_certification(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_certification).toList();
  }

  @protected
  List<CertificationSet> dco_decode_list_certification_set(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_certification_set).toList();
  }

  @protected
  List<GraphEdge> dco_decode_list_graph_edge(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_graph_edge).toList();
  }

  @protected
  List<PgpCertWithIds> dco_decode_list_pgp_cert_with_ids(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_pgp_cert_with_ids).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String?, List<Certification>)>
  dco_decode_list_record_opt_string_list_certification(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_opt_string_list_certification)
        .toList();
  }

  @protected
  List<(String, UserId)>
  dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id,
        )
        .toList();
  }

  @protected
  List<(String, GraphVertex)> dco_decode_list_record_string_graph_vertex(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_graph_vertex)
        .toList();
  }

  @protected
  OnConflict dco_decode_on_conflict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnConflict.values[raw as int];
  }

  @protected
  OnlyFingerprint dco_decode_only_fingerprint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OnlyFingerprint(fingerprint: dco_decode_String(arr[0]));
  }

  @protected
  OnlyOnline dco_decode_only_online(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OnlyOnline(online: dco_decode_bool(arr[0]));
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  UuidValue? dco_decode_opt_Uuid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Uuid(raw);
  }

  @protected
  NewsGroup?
  dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            raw,
          );
  }

  @protected
  OnlyFingerprint? dco_decode_opt_box_autoadd_only_fingerprint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_only_fingerprint(raw);
  }

  @protected
  OnlyOnline? dco_decode_opt_box_autoadd_only_online(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_only_online(raw);
  }

  @protected
  PgpCertWithIds? dco_decode_opt_box_autoadd_pgp_cert_with_ids(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_pgp_cert_with_ids(raw);
  }

  @protected
  QrCodeContent? dco_decode_opt_box_autoadd_qr_code_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_qr_code_content(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_usize(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PgpCert dco_decode_pgp_cert(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PgpCert(
      keyid: dco_decode_String(arr[0]),
      fingerprint:
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
            arr[1],
          ),
      hasPrivate: dco_decode_bool(arr[2]),
      online: dco_decode_bool(arr[3]),
    );
  }

  @protected
  PgpCertStubSigs dco_decode_pgp_cert_stub_sigs(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PgpCertStubSigs(
      cert: dco_decode_pgp_cert(arr[0]),
      ids: dco_decode_list_String(arr[1]),
      sigs: dco_decode_list_String(arr[2]),
      certifications: dco_decode_list_String(arr[3]),
    );
  }

  @protected
  PgpCertWithIds dco_decode_pgp_cert_with_ids(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PgpCertWithIds(
      cert: dco_decode_pgp_cert(arr[0]),
      ids: dco_decode_list_String(arr[1]),
      sigs:
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
            arr[2],
          ),
      certifications:
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
            arr[3],
          ),
    );
  }

  @protected
  PgpImportImplementor dco_decode_pgp_import_implementor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PgpImportImplementor_Variant0(
          dco_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
            raw[1],
          ),
        );
      case 1:
        return PgpImportImplementor_Variant1(
          dco_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
            raw[1],
          ),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  QrCodeContent dco_decode_qr_code_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return QrCodeContent(
      resource: dco_decode_String(arr[0]),
      handle: dco_decode_opt_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  QrCodeKey dco_decode_qr_code_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return QrCodeKey(
      content: dco_decode_list_prim_u_8_strict(arr[0]),
      fullkey: dco_decode_opt_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  (String?, List<Certification>)
  dco_decode_record_opt_string_list_certification(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_opt_String(arr[0]),
      dco_decode_list_certification(arr[1]),
    );
  }

  @protected
  (String, UserId)
  dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
        arr[1],
      ),
    );
  }

  @protected
  (String, GraphVertex) dco_decode_record_string_graph_vertex(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (dco_decode_String(arr[0]), dco_decode_graph_vertex(arr[1]));
  }

  @protected
  TrustLevel dco_decode_trust_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return TrustLevel_Ultimate();
      case 1:
        return TrustLevel_Full();
      case 2:
        return TrustLevel_Partial();
      case 3:
        return TrustLevel_Custom(dco_decode_u_8(raw[1]));
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VerifyResult dco_decode_verify_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return VerifyResult(
      fingerprints: dco_decode_list_String(arr[0]),
      content: dco_decode_opt_box_autoadd_qr_code_content(arr[1]),
      key: dco_decode_opt_box_autoadd_pgp_cert_with_ids(arr[2]),
      isStub: dco_decode_bool(arr[3]),
    );
  }

  @protected
  VisualKey dco_decode_visual_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return VisualKey(
      gismu: dco_decode_list_String(arr[0]),
      emoji: dco_decode_list_String(arr[1]),
      phone: dco_decode_String(arr[2]),
    );
  }

  @protected
  WotGraph dco_decode_wot_graph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WotGraph(
      edges: dco_decode_Set_graph_edge_None(arr[0]),
      vertices: dco_decode_Map_String_graph_vertex_None(arr[1]),
      trust: dco_decode_usize(arr[2]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ResultCertParser
  sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
          deserializer,
        );
    return inner;
  }

  @protected
  PgpImportBytes
  sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
          deserializer,
        );
    return inner;
  }

  @protected
  PgpImportFile
  sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
          deserializer,
        );
    return inner;
  }

  @protected
  ArcLazyCert
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcLazyCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  GenerateCert
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GenerateCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  MaybeCert
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MaybeCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  NewsGroup
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PathBuf
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PathBufImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpApp
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpAppImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpDataCert
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportBytes
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportFile
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SharedNetwork
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SqliteDb
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SqliteDbImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  StoreNetwork
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  UserHandle
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UserHandleImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  UserId
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UserIdImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Watcher
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  NewsGroup
  sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  MaybeCert
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MaybeCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  NewsGroup
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpApp
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpAppImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpDataCert
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportBytes
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportFile
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SharedNetwork
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SqliteDb
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SqliteDbImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  StoreNetwork
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  UserHandle
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UserHandleImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Watcher
  sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  PgpImport sse_decode_DynTrait_PgpImport(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  ResultCertParser
  sse_decode_Lifetimeable_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultCertParserstatic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
          deserializer,
        );
    return inner;
  }

  @protected
  Map<String, GraphVertex> sse_decode_Map_String_graph_vertex_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_graph_vertex(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  ArcLazyCert
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcLazyCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  GenerateCert
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GenerateCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  ResultCertParser
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ResultCertParserImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  MaybeCert
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MaybeCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  NewsGroup
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PathBuf
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PathBufImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpApp
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpAppImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpDataCert
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpDataCertImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportBytes
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportBytesImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  PgpImportFile
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PgpImportFileImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SharedNetwork
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SharedNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  SqliteDb
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SqliteDbImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  StoreNetwork
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StoreNetworkImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  UserHandle
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UserHandleImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  UserId
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UserIdImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Watcher
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Set<GraphEdge> sse_decode_Set_graph_edge_None(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_graph_edge(deserializer);
    return Set.from(inner);
  }

  @protected
  RustStreamSink<String> sse_decode_StreamSink_String_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<PgpCertWithIds> sse_decode_StreamSink_pgp_cert_with_ids_Sse(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  UuidValue sse_decode_Uuid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return UuidValue.fromByteList(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  NewsGroup
  sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
      deserializer,
    ));
  }

  @protected
  Config sse_decode_box_autoadd_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_config(deserializer));
  }

  @protected
  KeyHandle sse_decode_box_autoadd_key_handle(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_key_handle(deserializer));
  }

  @protected
  OnlyFingerprint sse_decode_box_autoadd_only_fingerprint(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_only_fingerprint(deserializer));
  }

  @protected
  OnlyOnline sse_decode_box_autoadd_only_online(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_only_online(deserializer));
  }

  @protected
  PgpCertWithIds sse_decode_box_autoadd_pgp_cert_with_ids(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pgp_cert_with_ids(deserializer));
  }

  @protected
  PgpImportImplementor sse_decode_box_autoadd_pgp_import_implementor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pgp_import_implementor(deserializer));
  }

  @protected
  QrCodeContent sse_decode_box_autoadd_qr_code_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_qr_code_content(deserializer));
  }

  @protected
  TrustLevel sse_decode_box_autoadd_trust_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_trust_level(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_usize(deserializer));
  }

  @protected
  CertSynopsis sse_decode_cert_synopsis(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fingerprint = sse_decode_String(deserializer);
    var var_keyid = sse_decode_String(deserializer);
    var var_keyHandle = sse_decode_key_handle(deserializer);
    var var_revoked = sse_decode_bool(deserializer);
    var var_userids = sse_decode_list_String(deserializer);
    return CertSynopsis(
      fingerprint: var_fingerprint,
      keyid: var_keyid,
      keyHandle: var_keyHandle,
      revoked: var_revoked,
      userids: var_userids,
    );
  }

  @protected
  Certification sse_decode_certification(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_issuer = sse_decode_String(deserializer);
    var var_target = sse_decode_String(deserializer);
    return Certification(issuer: var_issuer, target: var_target);
  }

  @protected
  CertificationSet sse_decode_certification_set(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_issuer = sse_decode_String(deserializer);
    var var_target = sse_decode_String(deserializer);
    var var_certifications =
        sse_decode_list_record_opt_string_list_certification(deserializer);
    return CertificationSet(
      issuer: var_issuer,
      target: var_target,
      certifications: var_certifications,
    );
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_keystorePath =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
          deserializer,
        );
    var var_dbPath =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
          deserializer,
        );
    return Config.raw(keystorePath: var_keystorePath, dbPath: var_dbPath);
  }

  @protected
  GraphEdge sse_decode_graph_edge(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_srcId = sse_decode_String(deserializer);
    var var_dstId = sse_decode_String(deserializer);
    var var_ranking = sse_decode_i_64(deserializer);
    var var_edgeName = sse_decode_String(deserializer);
    return GraphEdge(
      srcId: var_srcId,
      dstId: var_dstId,
      ranking: var_ranking,
      edgeName: var_edgeName,
    );
  }

  @protected
  GraphVertex sse_decode_graph_vertex(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_tag = sse_decode_String(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    var var_data = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return GraphVertex(
      id: var_id,
      tag: var_tag,
      tags: var_tags,
      data: var_data,
    );
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  KeyHandle sse_decode_key_handle(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return KeyHandle_KeyId(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return KeyHandle_Fingerprint(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<MaybeCert>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MaybeCert>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<NewsGroup>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NewsGroup>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<PgpDataCert>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PgpDataCert>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<UserId>
  sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UserId>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<CertSynopsis> sse_decode_list_cert_synopsis(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CertSynopsis>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_cert_synopsis(deserializer));
    }
    return ans_;
  }

  @protected
  List<Certification> sse_decode_list_certification(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Certification>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_certification(deserializer));
    }
    return ans_;
  }

  @protected
  List<CertificationSet> sse_decode_list_certification_set(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CertificationSet>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_certification_set(deserializer));
    }
    return ans_;
  }

  @protected
  List<GraphEdge> sse_decode_list_graph_edge(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GraphEdge>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_graph_edge(deserializer));
    }
    return ans_;
  }

  @protected
  List<PgpCertWithIds> sse_decode_list_pgp_cert_with_ids(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PgpCertWithIds>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pgp_cert_with_ids(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String?, List<Certification>)>
  sse_decode_list_record_opt_string_list_certification(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String?, List<Certification>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_opt_string_list_certification(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, UserId)>
  sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, UserId)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<(String, GraphVertex)> sse_decode_list_record_string_graph_vertex(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, GraphVertex)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_graph_vertex(deserializer));
    }
    return ans_;
  }

  @protected
  OnConflict sse_decode_on_conflict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return OnConflict.values[inner];
  }

  @protected
  OnlyFingerprint sse_decode_only_fingerprint(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fingerprint = sse_decode_String(deserializer);
    return OnlyFingerprint(fingerprint: var_fingerprint);
  }

  @protected
  OnlyOnline sse_decode_only_online(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_online = sse_decode_bool(deserializer);
    return OnlyOnline(online: var_online);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UuidValue? sse_decode_opt_Uuid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Uuid(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NewsGroup?
  sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        deserializer,
      ));
    } else {
      return null;
    }
  }

  @protected
  OnlyFingerprint? sse_decode_opt_box_autoadd_only_fingerprint(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_only_fingerprint(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OnlyOnline? sse_decode_opt_box_autoadd_only_online(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_only_online(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PgpCertWithIds? sse_decode_opt_box_autoadd_pgp_cert_with_ids(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_pgp_cert_with_ids(deserializer));
    } else {
      return null;
    }
  }

  @protected
  QrCodeContent? sse_decode_opt_box_autoadd_qr_code_content(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_qr_code_content(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_usize(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PgpCert sse_decode_pgp_cert(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_keyid = sse_decode_String(deserializer);
    var var_fingerprint =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
          deserializer,
        );
    var var_hasPrivate = sse_decode_bool(deserializer);
    var var_online = sse_decode_bool(deserializer);
    return PgpCert(
      keyid: var_keyid,
      fingerprint: var_fingerprint,
      hasPrivate: var_hasPrivate,
      online: var_online,
    );
  }

  @protected
  PgpCertStubSigs sse_decode_pgp_cert_stub_sigs(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cert = sse_decode_pgp_cert(deserializer);
    var var_ids = sse_decode_list_String(deserializer);
    var var_sigs = sse_decode_list_String(deserializer);
    var var_certifications = sse_decode_list_String(deserializer);
    return PgpCertStubSigs(
      cert: var_cert,
      ids: var_ids,
      sigs: var_sigs,
      certifications: var_certifications,
    );
  }

  @protected
  PgpCertWithIds sse_decode_pgp_cert_with_ids(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cert = sse_decode_pgp_cert(deserializer);
    var var_ids = sse_decode_list_String(deserializer);
    var var_sigs =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
          deserializer,
        );
    var var_certifications =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
          deserializer,
        );
    return PgpCertWithIds(
      cert: var_cert,
      ids: var_ids,
      sigs: var_sigs,
      certifications: var_certifications,
    );
  }

  @protected
  PgpImportImplementor sse_decode_pgp_import_implementor(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
              deserializer,
            );
        return PgpImportImplementor_Variant0(var_field0);
      case 1:
        var var_field0 =
            sse_decode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
              deserializer,
            );
        return PgpImportImplementor_Variant1(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  QrCodeContent sse_decode_qr_code_content(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_resource = sse_decode_String(deserializer);
    var var_handle = sse_decode_opt_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    return QrCodeContent(
      resource: var_resource,
      handle: var_handle,
      description: var_description,
    );
  }

  @protected
  QrCodeKey sse_decode_qr_code_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_list_prim_u_8_strict(deserializer);
    var var_fullkey = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return QrCodeKey(content: var_content, fullkey: var_fullkey);
  }

  @protected
  (String?, List<Certification>)
  sse_decode_record_opt_string_list_certification(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_opt_String(deserializer);
    var var_field1 = sse_decode_list_certification(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, UserId)
  sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
          deserializer,
        );
    return (var_field0, var_field1);
  }

  @protected
  (String, GraphVertex) sse_decode_record_string_graph_vertex(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_graph_vertex(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  TrustLevel sse_decode_trust_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return TrustLevel_Ultimate();
      case 1:
        return TrustLevel_Full();
      case 2:
        return TrustLevel_Partial();
      case 3:
        var var_field0 = sse_decode_u_8(deserializer);
        return TrustLevel_Custom(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VerifyResult sse_decode_verify_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fingerprints = sse_decode_list_String(deserializer);
    var var_content = sse_decode_opt_box_autoadd_qr_code_content(deserializer);
    var var_key = sse_decode_opt_box_autoadd_pgp_cert_with_ids(deserializer);
    var var_isStub = sse_decode_bool(deserializer);
    return VerifyResult(
      fingerprints: var_fingerprints,
      content: var_content,
      key: var_key,
      isStub: var_isStub,
    );
  }

  @protected
  VisualKey sse_decode_visual_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gismu = sse_decode_list_String(deserializer);
    var var_emoji = sse_decode_list_String(deserializer);
    var var_phone = sse_decode_String(deserializer);
    return VisualKey(gismu: var_gismu, emoji: var_emoji, phone: var_phone);
  }

  @protected
  WotGraph sse_decode_wot_graph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_edges = sse_decode_Set_graph_edge_None(deserializer);
    var var_vertices = sse_decode_Map_String_graph_vertex_None(deserializer);
    var var_trust = sse_decode_usize(deserializer);
    return WotGraph(edges: var_edges, vertices: var_vertices, trust: var_trust);
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
  sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    ResultCertParser self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
      self,
      serializer,
    );
  }

  @protected
  void
  sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    PgpImportBytes self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
      self,
      serializer,
    );
  }

  @protected
  void
  sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    PgpImportFile self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
      self,
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    ArcLazyCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcLazyCertImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    GenerateCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as GenerateCertImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    MaybeCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MaybeCertImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as NewsGroupImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    PathBuf self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PathBufImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    PgpApp self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpAppImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    PgpDataCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpDataCertImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    PgpImportBytes self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportBytesImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    PgpImportFile self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportFileImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SharedNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SharedNetworkImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SqliteDb self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SqliteDbImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    StoreNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as StoreNetworkImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    UserHandle self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as UserHandleImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    UserId self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as UserIdImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    Watcher self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as WatcherImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as NewsGroupImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    MaybeCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MaybeCertImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as NewsGroupImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    PgpApp self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpAppImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    PgpDataCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpDataCertImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    PgpImportBytes self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportBytesImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    PgpImportFile self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportFileImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SharedNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SharedNetworkImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SqliteDb self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SqliteDbImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    StoreNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as StoreNetworkImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    UserHandle self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as UserHandleImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    Watcher self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as WatcherImpl).frbInternalSseEncode(move: false),
      serializer,
    );
  }

  @protected
  void
  sse_encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb_Output_unit_AnyhowException(
    FutureOr<void> Function(SqliteDb) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
      encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb_Output_unit_AnyhowException(
        self,
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
      PlatformPointerUtil.ptrToPlatformInt64(
        encodeDartOpaque(
          self,
          portManager.dartHandlerPort,
          generalizedFrbRustBinding,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_DynTrait_PgpImport(PgpImport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pgp_import_implementor(
      (() {
        if (self is PgpImportBytes) {
          return PgpImportImplementor.variant0(self);
        }
        if (self is PgpImportFile) {
          return PgpImportImplementor.variant1(self);
        }

        throw Exception('not reachable');
      })(),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Lifetimeable_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResultCertParserstatic(
    ResultCertParser self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
      self,
      serializer,
    );
  }

  @protected
  void sse_encode_Map_String_graph_vertex_None(
    Map<String, GraphVertex> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_graph_vertex(
      self.entries.map((e) => (e.key, e.value)).toList(),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcLazyCertstatic(
    ArcLazyCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ArcLazyCertImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGenerateCert(
    GenerateCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as GenerateCertImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLifetimeableResultCertParserstatic(
    ResultCertParser self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ResultCertParserImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    MaybeCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as MaybeCertImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as NewsGroupImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
    PathBuf self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PathBufImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpApp(
    PgpApp self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpAppImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    PgpDataCert self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpDataCertImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
    PgpImportBytes self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportBytesImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
    PgpImportFile self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as PgpImportFileImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSharedNetwork(
    SharedNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SharedNetworkImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSqliteDb(
    SqliteDb self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as SqliteDbImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStoreNetwork(
    StoreNetwork self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as StoreNetworkImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
    UserHandle self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as UserHandleImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    UserId self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as UserIdImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
    Watcher self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as WatcherImpl).frbInternalSseEncode(move: null),
      serializer,
    );
  }

  @protected
  void sse_encode_Set_graph_edge_None(
    Set<GraphEdge> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_graph_edge(self.toList(), serializer);
  }

  @protected
  void sse_encode_StreamSink_String_Sse(
    RustStreamSink<String> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_StreamSink_pgp_cert_with_ids_Sse(
    RustStreamSink<PgpCertWithIds> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
      self.setupAndSerialize(
        codec: SseCodec(
          decodeSuccessData: sse_decode_pgp_cert_with_ids,
          decodeErrorData: sse_decode_AnyhowException,
        ),
      ),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_Uuid(UuidValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.toBytes(), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
  sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
      self,
      serializer,
    );
  }

  @protected
  void sse_encode_box_autoadd_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_key_handle(
    KeyHandle self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_key_handle(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_only_fingerprint(
    OnlyFingerprint self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_only_fingerprint(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_only_online(
    OnlyOnline self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_only_online(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pgp_cert_with_ids(
    PgpCertWithIds self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pgp_cert_with_ids(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pgp_import_implementor(
    PgpImportImplementor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pgp_import_implementor(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_qr_code_content(
    QrCodeContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_qr_code_content(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_trust_level(
    TrustLevel self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_trust_level(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self, serializer);
  }

  @protected
  void sse_encode_cert_synopsis(CertSynopsis self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.fingerprint, serializer);
    sse_encode_String(self.keyid, serializer);
    sse_encode_key_handle(self.keyHandle, serializer);
    sse_encode_bool(self.revoked, serializer);
    sse_encode_list_String(self.userids, serializer);
  }

  @protected
  void sse_encode_certification(Certification self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.issuer, serializer);
    sse_encode_String(self.target, serializer);
  }

  @protected
  void sse_encode_certification_set(
    CertificationSet self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.issuer, serializer);
    sse_encode_String(self.target, serializer);
    sse_encode_list_record_opt_string_list_certification(
      self.certifications,
      serializer,
    );
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
      self.keystorePath,
      serializer,
    );
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPathBuf(
      self.dbPath,
      serializer,
    );
  }

  @protected
  void sse_encode_graph_edge(GraphEdge self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.srcId, serializer);
    sse_encode_String(self.dstId, serializer);
    sse_encode_i_64(self.ranking, serializer);
    sse_encode_String(self.edgeName, serializer);
  }

  @protected
  void sse_encode_graph_vertex(GraphVertex self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.tag, serializer);
    sse_encode_list_String(self.tags, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_key_handle(KeyHandle self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case KeyHandle_KeyId(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case KeyHandle_Fingerprint(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
    List<MaybeCert> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
        item,
        serializer,
      );
    }
  }

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    List<NewsGroup> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        item,
        serializer,
      );
    }
  }

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
    List<PgpDataCert> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpDataCert(
        item,
        serializer,
      );
    }
  }

  @protected
  void
  sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
    List<UserId> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
        item,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_cert_synopsis(
    List<CertSynopsis> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_cert_synopsis(item, serializer);
    }
  }

  @protected
  void sse_encode_list_certification(
    List<Certification> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_certification(item, serializer);
    }
  }

  @protected
  void sse_encode_list_certification_set(
    List<CertificationSet> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_certification_set(item, serializer);
    }
  }

  @protected
  void sse_encode_list_graph_edge(
    List<GraphEdge> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_graph_edge(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pgp_cert_with_ids(
    List<PgpCertWithIds> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pgp_cert_with_ids(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_opt_string_list_certification(
    List<(String?, List<Certification>)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_opt_string_list_certification(item, serializer);
    }
  }

  @protected
  void
  sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    List<(String, UserId)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
        item,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_list_record_string_graph_vertex(
    List<(String, GraphVertex)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_graph_vertex(item, serializer);
    }
  }

  @protected
  void sse_encode_on_conflict(OnConflict self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_only_fingerprint(
    OnlyFingerprint self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.fingerprint, serializer);
  }

  @protected
  void sse_encode_only_online(OnlyOnline self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.online, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_Uuid(UuidValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Uuid(self, serializer);
    }
  }

  @protected
  void
  sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
    NewsGroup? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        self,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_only_fingerprint(
    OnlyFingerprint? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_only_fingerprint(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_only_online(
    OnlyOnline? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_only_online(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_pgp_cert_with_ids(
    PgpCertWithIds? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_pgp_cert_with_ids(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_qr_code_content(
    QrCodeContent? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_qr_code_content(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_usize(
    BigInt? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
    List<String>? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
    Uint8List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_pgp_cert(PgpCert self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.keyid, serializer);
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserHandle(
      self.fingerprint,
      serializer,
    );
    sse_encode_bool(self.hasPrivate, serializer);
    sse_encode_bool(self.online, serializer);
  }

  @protected
  void sse_encode_pgp_cert_stub_sigs(
    PgpCertStubSigs self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pgp_cert(self.cert, serializer);
    sse_encode_list_String(self.ids, serializer);
    sse_encode_list_String(self.sigs, serializer);
    sse_encode_list_String(self.certifications, serializer);
  }

  @protected
  void sse_encode_pgp_cert_with_ids(
    PgpCertWithIds self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pgp_cert(self.cert, serializer);
    sse_encode_list_String(self.ids, serializer);
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
      self.sigs,
      serializer,
    );
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaybeCert(
      self.certifications,
      serializer,
    );
  }

  @protected
  void sse_encode_pgp_import_implementor(
    PgpImportImplementor self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PgpImportImplementor_Variant0(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportBytes(
          field0,
          serializer,
        );
      case PgpImportImplementor_Variant1(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_AutoExplicit_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPgpImportFile(
          field0,
          serializer,
        );
    }
  }

  @protected
  void sse_encode_qr_code_content(
    QrCodeContent self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.resource, serializer);
    sse_encode_opt_String(self.handle, serializer);
    sse_encode_opt_String(self.description, serializer);
  }

  @protected
  void sse_encode_qr_code_key(QrCodeKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.content, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.fullkey, serializer);
  }

  @protected
  void sse_encode_record_opt_string_list_certification(
    (String?, List<Certification>) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.$1, serializer);
    sse_encode_list_certification(self.$2, serializer);
  }

  @protected
  void
  sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_user_id(
    (String, UserId) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserID(
      self.$2,
      serializer,
    );
  }

  @protected
  void sse_encode_record_string_graph_vertex(
    (String, GraphVertex) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_graph_vertex(self.$2, serializer);
  }

  @protected
  void sse_encode_trust_level(TrustLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case TrustLevel_Ultimate():
        sse_encode_i_32(0, serializer);
      case TrustLevel_Full():
        sse_encode_i_32(1, serializer);
      case TrustLevel_Partial():
        sse_encode_i_32(2, serializer);
      case TrustLevel_Custom(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_u_8(field0, serializer);
    }
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_verify_result(VerifyResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.fingerprints, serializer);
    sse_encode_opt_box_autoadd_qr_code_content(self.content, serializer);
    sse_encode_opt_box_autoadd_pgp_cert_with_ids(self.key, serializer);
    sse_encode_bool(self.isStub, serializer);
  }

  @protected
  void sse_encode_visual_key(VisualKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.gismu, serializer);
    sse_encode_list_String(self.emoji, serializer);
    sse_encode_String(self.phone, serializer);
  }

  @protected
  void sse_encode_wot_graph(WotGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Set_graph_edge_None(self.edges, serializer);
    sse_encode_Map_String_graph_vertex_None(self.vertices, serializer);
    sse_encode_usize(self.trust, serializer);
  }
}

@freezed
sealed class PgpImportImplementor with _$PgpImportImplementor {
  const PgpImportImplementor._();

  const factory PgpImportImplementor.variant0(PgpImportBytes field0) =
      PgpImportImplementor_Variant0;
  const factory PgpImportImplementor.variant1(PgpImportFile field0) =
      PgpImportImplementor_Variant1;
}

@sealed
class ArcLazyCertImpl extends RustOpaque implements ArcLazyCert {
  // Not to be used by end users
  ArcLazyCertImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcLazyCertImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcLazyCert,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcLazyCert,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcLazyCertPtr,
  );
}

@sealed
class GenerateCertImpl extends RustOpaque implements GenerateCert {
  // Not to be used by end users
  GenerateCertImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GenerateCertImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_GenerateCert,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_GenerateCert,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GenerateCertPtr,
  );

  GenerateCert comment({required String comment}) => RustLib.instance.api
      .crateApiPgpKeysGenerateCertComment(that: this, comment: comment);

  Future<PgpCertWithIds> generate() =>
      RustLib.instance.api.crateApiPgpKeysGenerateCertGenerate(that: this);

  GenerateCert name({required String name}) => RustLib.instance.api
      .crateApiPgpKeysGenerateCertName(that: this, name: name);

  GenerateCert online({required bool online}) => RustLib.instance.api
      .crateApiPgpKeysGenerateCertOnline(that: this, online: online);
}

@sealed
class MaybeCertImpl extends RustOpaque implements MaybeCert {
  // Not to be used by end users
  MaybeCertImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MaybeCertImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MaybeCert,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MaybeCert,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MaybeCertPtr,
  );

  UserHandle fingerprint() =>
      RustLib.instance.api.crateApiPgpCertMaybeCertFingerprint(that: this);

  List<String>? maybeIds() =>
      RustLib.instance.api.crateApiPgpCertMaybeCertMaybeIds(that: this);
}

@sealed
class NewsGroupImpl extends RustOpaque implements NewsGroup {
  // Not to be used by end users
  NewsGroupImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NewsGroupImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_NewsGroup,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_NewsGroup,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_NewsGroupPtr,
  );

  String get description => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetDescription(that: this);

  String get groupName => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName(that: this);

  UuidValue? get parent => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetParent(that: this);

  Uint8List? get parentHash => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash(that: this);

  bool get sent => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetSent(that: this);

  UuidValue get uuid => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorGetUuid(that: this);

  set description(String description) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetDescription(
        that: this,
        description: description,
      );

  set groupName(String groupName) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName(
        that: this,
        groupName: groupName,
      );

  set parent(UuidValue? parent) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetParent(
        that: this,
        parent: parent,
      );

  set parentHash(Uint8List? parentHash) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash(
        that: this,
        parentHash: parentHash,
      );

  set sent(bool sent) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetSent(that: this, sent: sent);

  set uuid(UuidValue uuid) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetUuid(that: this, uuid: uuid);

  Future<void> delete({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupDelete(that: this, conn: conn);

  Future<void> insert({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupInsert(that: this, conn: conn);

  Future<void> insertOnConflict({
    required SqliteDb conn,
    required OnConflict onConflict,
  }) => RustLib.instance.api.crateApiDbEntitiesNewsGroupInsertOnConflict(
    that: this,
    conn: conn,
    onConflict: onConflict,
  );

  Future<void> update({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupUpdate(that: this, conn: conn);
}

@sealed
class PathBufImpl extends RustOpaque implements PathBuf {
  // Not to be used by end users
  PathBufImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PathBufImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PathBuf,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PathBuf,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PathBufPtr,
  );
}

@sealed
class PgpAppImpl extends RustOpaque implements PgpApp {
  // Not to be used by end users
  PgpAppImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PgpAppImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PgpApp,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpApp,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpAppPtr,
  );

  Future<List<PgpCertWithIds>> allOwnedCerts() =>
      RustLib.instance.api.crateApiPgpAppAllOwnedCerts(that: this);

  Future<List<CertificationSet>> certificationsOf({
    required String target,
    BigInt? minDepth,
  }) => RustLib.instance.api.crateApiPgpAppCertificationsOf(
    that: this,
    target: target,
    minDepth: minDepth,
  );

  Future<List<(String, UserId)>> certifiedUserids() =>
      RustLib.instance.api.crateApiPgpAppCertifiedUserids(that: this);

  Future<List<UserId>> certifiedUseridsOf({required String fpr}) => RustLib
      .instance
      .api
      .crateApiPgpAppCertifiedUseridsOf(that: this, fpr: fpr);

  Future<void> deleteCert({required UserHandle fingerprint}) => RustLib
      .instance
      .api
      .crateApiPgpAppDeleteCert(that: this, fingerprint: fingerprint);

  Future<void> deletePrivateKey({required UserHandle fingerprint}) => RustLib
      .instance
      .api
      .crateApiPgpAppDeletePrivateKey(that: this, fingerprint: fingerprint);

  Future<String> exportArmor() =>
      RustLib.instance.api.crateApiPgpAppExportArmor(that: this);

  Future<void> exportFile({required String file}) =>
      RustLib.instance.api.crateApiPgpAppExportFile(that: this, file: file);

  Future<void> fillFromKeyserver({
    required UserHandle fingerprint,
    required String server,
  }) => RustLib.instance.api.crateApiPgpAppFillFromKeyserver(
    that: this,
    fingerprint: fingerprint,
    server: server,
  );

  GenerateCert generateKey({required String email}) =>
      RustLib.instance.api.crateApiPgpAppGenerateKey(that: this, email: email);

  Future<PgpCertWithIds?> getCertByRole({required String role}) =>
      RustLib.instance.api.crateApiPgpAppGetCertByRole(that: this, role: role);

  SqliteDb getDb() => RustLib.instance.api.crateApiPgpAppGetDb(that: this);

  Future<List<String>> getFingerprints() =>
      RustLib.instance.api.crateApiPgpAppGetFingerprints(that: this);

  Future<PgpCertWithIds> getKeyFromFingerprint({
    required UserHandle fingerprint,
  }) => RustLib.instance.api.crateApiPgpAppGetKeyFromFingerprint(
    that: this,
    fingerprint: fingerprint,
  );

  Future<Uint8List> getQr({
    required String resource,
    String? handle,
    String? description,
    required UserHandle key,
    required bool fullKey,
  }) => RustLib.instance.api.crateApiPgpAppGetQr(
    that: this,
    resource: resource,
    handle: handle,
    description: description,
    key: key,
    fullKey: fullKey,
  );

  Future<PgpCertWithIds> getStubFromFingerprint({
    required UserHandle fingerprint,
  }) => RustLib.instance.api.crateApiPgpAppGetStubFromFingerprint(
    that: this,
    fingerprint: fingerprint,
  );

  Watcher getWatcher() =>
      RustLib.instance.api.crateApiPgpAppGetWatcher(that: this);

  Future<void> importCerts({required PgpImport import_}) => RustLib.instance.api
      .crateApiPgpAppImportCerts(that: this, import_: import_);

  Future<bool> isStub({required String fingerprint}) => RustLib.instance.api
      .crateApiPgpAppIsStub(that: this, fingerprint: fingerprint);

  Stream<PgpCertWithIds> iterCerts() =>
      RustLib.instance.api.crateApiPgpAppIterCerts(that: this);

  Stream<PgpCertWithIds> iterCertsSearch({required String pattern}) => RustLib
      .instance
      .api
      .crateApiPgpAppIterCertsSearch(that: this, pattern: pattern);

  Stream<PgpCertWithIds> iterCertsSearchKeyid({required String pattern}) =>
      RustLib.instance.api.crateApiPgpAppIterCertsSearchKeyid(
        that: this,
        pattern: pattern,
      );

  Stream<String> iterFingerprints() =>
      RustLib.instance.api.crateApiPgpAppIterFingerprints(that: this);

  Future<List<CertSynopsis>> lookupSynopses({required KeyHandle kh}) =>
      RustLib.instance.api.crateApiPgpAppLookupSynopses(that: this, kh: kh);

  Future<List<(String, UserId)>> lookupSynopsesByEmail({
    required String email,
  }) => RustLib.instance.api.crateApiPgpAppLookupSynopsesByEmail(
    that: this,
    email: email,
  );

  Future<List<String>> lookupSynopsesByUserid({required UserId userid}) =>
      RustLib.instance.api.crateApiPgpAppLookupSynopsesByUserid(
        that: this,
        userid: userid,
      );

  Future<CertSynopsis> lookupSynopsisByFpr({required UserHandle fingerprint}) =>
      RustLib.instance.api.crateApiPgpAppLookupSynopsisByFpr(
        that: this,
        fingerprint: fingerprint,
      );

  Future<void> megaFlush() =>
      RustLib.instance.api.crateApiPgpAppMegaFlush(that: this);

  StoreNetwork networkFromFingerprints({required List<String> fingerprints}) =>
      RustLib.instance.api.crateApiPgpAppNetworkFromFingerprints(
        that: this,
        fingerprints: fingerprints,
      );

  Future<void> signWithTrustLevel({
    required String signer,
    required String signee,
    required int level,
    required TrustLevel trust,
  }) => RustLib.instance.api.crateApiPgpAppSignWithTrustLevel(
    that: this,
    signer: signer,
    signee: signee,
    level: level,
    trust: trust,
  );

  Future<List<CertSynopsis>> synopses() =>
      RustLib.instance.api.crateApiPgpAppSynopses(that: this);

  Future<List<Certification>> thirdPartyCertificationsOf({
    required String fpr,
  }) => RustLib.instance.api.crateApiPgpAppThirdPartyCertificationsOf(
    that: this,
    fpr: fpr,
  );

  StoreNetwork unrootedNetwork() =>
      RustLib.instance.api.crateApiPgpAppUnrootedNetwork(that: this);

  Future<void> updateCert({required ArcLazyCert cert}) =>
      RustLib.instance.api.crateApiPgpAppUpdateCert(that: this, cert: cert);

  Future<void> updateRole({
    required UserHandle fingerprint,
    required String role,
  }) => RustLib.instance.api.crateApiPgpAppUpdateRole(
    that: this,
    fingerprint: fingerprint,
    role: role,
  );

  Future<void> uploadToKeyserver({
    required UserHandle fingerprint,
    required String server,
  }) => RustLib.instance.api.crateApiPgpAppUploadToKeyserver(
    that: this,
    fingerprint: fingerprint,
    server: server,
  );

  Future<VerifyResult> verifyQrAllCerts({required List<int> content}) => RustLib
      .instance
      .api
      .crateApiPgpAppVerifyQrAllCerts(that: this, content: content);
}

@sealed
class PgpDataCertImpl extends RustOpaque implements PgpDataCert {
  // Not to be used by end users
  PgpDataCertImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PgpDataCertImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PgpDataCert,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpDataCert,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpDataCertPtr,
  );

  Future<void> delete({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbStorePgpDataCertDelete(that: this, conn: conn);

  Future<void> insert({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbStorePgpDataCertInsert(that: this, conn: conn);

  Future<void> insertOnConflict({
    required SqliteDb conn,
    required OnConflict onConflict,
  }) => RustLib.instance.api.crateApiDbStorePgpDataCertInsertOnConflict(
    that: this,
    conn: conn,
    onConflict: onConflict,
  );

  Future<void> update({required SqliteDb conn}) => RustLib.instance.api
      .crateApiDbStorePgpDataCertUpdate(that: this, conn: conn);
}

@sealed
class PgpImportBytesImpl extends RustOpaque implements PgpImportBytes {
  // Not to be used by end users
  PgpImportBytesImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PgpImportBytesImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PgpImportBytes,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpImportBytes,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpImportBytesPtr,
  );

  Future<void> accept({required List<int> bytes}) => RustLib.instance.api
      .crateApiPgpImportPgpImportBytesAccept(that: this, bytes: bytes);

  Future<ResultCertParser> getPackets() => RustLib.instance.api
      .crateApiPgpImportPgpImportBytesGetPackets(that: this);
}

@sealed
class PgpImportFileImpl extends RustOpaque implements PgpImportFile {
  // Not to be used by end users
  PgpImportFileImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PgpImportFileImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PgpImportFile,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpImportFile,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PgpImportFilePtr,
  );

  Future<ResultCertParser> getPackets() =>
      RustLib.instance.api.crateApiPgpImportPgpImportFileGetPackets(that: this);
}

@sealed
class ResultCertParserImpl extends RustOpaque implements ResultCertParser {
  // Not to be used by end users
  ResultCertParserImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ResultCertParserImpl.frbInternalSseDecode(
    BigInt ptr,
    int externalSizeOnNative,
  ) : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ResultCertParser,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ResultCertParser,
    rustArcDecrementStrongCountPtr: RustLib
        .instance
        .api
        .rust_arc_decrement_strong_count_ResultCertParserPtr,
  );
}

@sealed
class SharedNetworkImpl extends RustOpaque implements SharedNetwork {
  // Not to be used by end users
  SharedNetworkImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SharedNetworkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SharedNetwork,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SharedNetwork,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SharedNetworkPtr,
  );

  Future<WotGraph> authenticate({
    required String remote,
    required BigInt trust,
  }) => RustLib.instance.api.crateApiPgpWotNetworkSharedNetworkAuthenticate(
    that: this,
    remote: remote,
    trust: trust,
  );

  Future<WotGraph> dumpAll() => RustLib.instance.api
      .crateApiPgpWotNetworkSharedNetworkDumpAll(that: this);
}

@sealed
class SqliteDbImpl extends RustOpaque implements SqliteDb {
  // Not to be used by end users
  SqliteDbImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SqliteDbImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SqliteDb,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SqliteDb,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SqliteDbPtr,
  );

  Future<List<PgpDataCert>> allCerts() =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbAllCerts(that: this);

  Future<List<PgpDataCert>> allOwnedCerts() => RustLib.instance.api
      .crateApiDbConnectionSqliteDbAllOwnedCerts(that: this);

  Future<bool> checkOnline({required String fingerprint}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbCheckOnline(
        that: this,
        fingerprint: fingerprint,
      );

  Future<void> clearRole({required String role}) => RustLib.instance.api
      .crateApiDbConnectionSqliteDbClearRole(that: this, role: role);

  Future<void> deleteByFingerprint({required String fingerprint}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbDeleteByFingerprint(
        that: this,
        fingerprint: fingerprint,
      );

  Future<List<PgpDataCert>> getByDomain({required String domain}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGetByDomain(that: this, domain: domain);

  Future<List<PgpDataCert>> getByEmail({required String email}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGetByEmail(that: this, email: email);

  Future<PgpDataCert> getByFingerprint({required String fingerprint}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGetByFingerprint(
        that: this,
        fingerprint: fingerprint,
      );

  Future<List<PgpDataCert>> getById({required String keyId}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGetById(that: this, keyId: keyId);

  Future<List<PgpDataCert>> getByUserid({required String userid}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGetByUserid(that: this, userid: userid);

  Future<void> getConnection() => RustLib.instance.api
      .crateApiDbConnectionSqliteDbGetConnection(that: this);

  Future<OnlyFingerprint?> getFingerprintForRole({required String role}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGetFingerprintForRole(
        that: this,
        role: role,
      );

  Watcher getWatcher() =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGetWatcher(that: this);

  Future<List<PgpDataCert>> grepByEmail({required String email}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGrepByEmail(that: this, email: email);

  Future<List<PgpDataCert>> grepByEmailAnchorEnd({required String email}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGrepByEmailAnchorEnd(
        that: this,
        email: email,
      );

  Future<List<PgpDataCert>> grepByEmailAnchorStart({required String email}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGrepByEmailAnchorStart(
        that: this,
        email: email,
      );

  Future<List<PgpDataCert>> grepByUserid({required String userid}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbGrepByUserid(that: this, userid: userid);

  Future<List<PgpDataCert>> grepByUseridAnchorEnd({required String userid}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGrepByUseridAnchorEnd(
        that: this,
        userid: userid,
      );

  Future<List<PgpDataCert>> grepByUseridAnchorStart({required String userid}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbGrepByUseridAnchorStart(
        that: this,
        userid: userid,
      );

  Future<void> insertGroup({required NewsGroup group}) => RustLib.instance.api
      .crateApiDbConnectionSqliteDbInsertGroup(that: this, group: group);

  Future<OnlyOnline?> isOnline({required String fingerprint}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbIsOnline(
        that: this,
        fingerprint: fingerprint,
      );

  Future<List<PgpDataCert>> searchOwnedCerts({required String userid}) =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbSearchOwnedCerts(
        that: this,
        userid: userid,
      );

  Future<List<NewsGroup>> test({required UuidValue uuid}) => RustLib
      .instance
      .api
      .crateApiDbConnectionSqliteDbTest(that: this, uuid: uuid);

  Future<NewsGroup?> testNullable() =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbTestNullable(that: this);

  Future<NewsGroup> testOne() =>
      RustLib.instance.api.crateApiDbConnectionSqliteDbTestOne(that: this);

  Future<void> updateRole({
    required String fingerprint,
    required String role,
  }) => RustLib.instance.api.crateApiDbConnectionSqliteDbUpdateRole(
    that: this,
    fingerprint: fingerprint,
    role: role,
  );
}

@sealed
class StoreNetworkImpl extends RustOpaque implements StoreNetwork {
  // Not to be used by end users
  StoreNetworkImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  StoreNetworkImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_StoreNetwork,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_StoreNetwork,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_StoreNetworkPtr,
  );

  Future<WotGraph> authenticate({
    required String remote,
    required BigInt trust,
  }) => RustLib.instance.api.crateApiPgpWotNetworkStoreNetworkAuthenticate(
    that: this,
    remote: remote,
    trust: trust,
  );

  Future<WotGraph> dumpAll() =>
      RustLib.instance.api.crateApiPgpWotNetworkStoreNetworkDumpAll(that: this);
}

@sealed
class UserHandleImpl extends RustOpaque implements UserHandle {
  // Not to be used by end users
  UserHandleImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UserHandleImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_UserHandle,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserHandle,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserHandlePtr,
  );

  String composite() =>
      RustLib.instance.api.crateApiPgpUserHandleComposite(that: this);

  String compositeLujvo({required bool short}) => RustLib.instance.api
      .crateApiPgpUserHandleCompositeLujvo(that: this, short: short);

  String compositeLujvoOrElse({required bool short}) => RustLib.instance.api
      .crateApiPgpUserHandleCompositeLujvoOrElse(that: this, short: short);

  String name() => RustLib.instance.api.crateApiPgpUserHandleName(that: this);

  VisualKey separate() =>
      RustLib.instance.api.crateApiPgpUserHandleSeparate(that: this);

  VisualKey separateLujvo() =>
      RustLib.instance.api.crateApiPgpUserHandleSeparateLujvo(that: this);
}

@sealed
class UserIdImpl extends RustOpaque implements UserId {
  // Not to be used by end users
  UserIdImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UserIdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_UserId,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserId,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserIdPtr,
  );
}

@sealed
class WatcherImpl extends RustOpaque implements Watcher {
  // Not to be used by end users
  WatcherImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  WatcherImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Watcher,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Watcher,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WatcherPtr,
  );

  void watch({
    required String table,
    required FutureOr<void> Function(SqliteDb) cb,
  }) => RustLib.instance.api.crateApiDbConnectionWatcherWatch(
    that: this,
    table: table,
    cb: cb,
  );
}
