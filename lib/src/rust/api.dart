// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'api/db.dart';
import 'api/db/connection.dart';
import 'api/pgp.dart';
import 'api/pgp/cert.dart';
import 'api/pgp/import.dart';
import 'api/pgp/keys.dart';
import 'api/pgp/sign.dart';
import 'api/pgp/wot/network.dart';
import 'api/ser.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `private_cert`
// These functions are ignored because they have generic arguments: `network`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `LOGGER`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `deref`, `initialize`

Future<void> initLogging() => RustLib.instance.api.crateApiInitLogging();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < LazyCert < 'static > >>>
abstract class ArcLazyCert implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>
abstract class PathBuf implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PgpApp>>
abstract class PgpApp
    implements
        RustOpaqueInterface,
        CertStoreTrait,
        PgpAppTrait,
        PgpServiceTrait {
  @override
  Future<List<PgpCertWithIds>> allOwnedCerts();

  @override
  Future<List<CertificationSet>> certificationsOf({
    required String target,
    BigInt? minDepth,
  });

  @override
  Future<List<(String, UserId)>> certifiedUserids();

  @override
  Future<List<UserId>> certifiedUseridsOf({required String fpr});

  static Future<PgpApp> create({required Config config}) =>
      RustLib.instance.api.crateApiPgpAppCreate(config: config);

  @override
  Future<void> deleteCert({required String fingerprint});

  @override
  Future<void> deletePrivateKey({required String fingerprint});

  @override
  Future<String> exportArmor();

  @override
  Future<void> exportFile({required String file});

  Future<void> fillFromKeyserver({
    required String fingerprint,
    required String server,
  });

  @override
  GenerateCert generateKey({required String email});

  @override
  Future<PgpCertWithIds?> getCertByRole({required String role});

  @override
  SqliteDb getDb();

  @override
  Future<List<String>> getFingerprints();

  @override
  Future<PgpCertWithIds> getKeyFromFingerprint({
    required UserHandle fingerprint,
  });

  Future<Uint8List> getQr({
    required String resource,
    String? handle,
    String? description,
    required String key,
    required bool fullKey,
  });

  @override
  Watcher getWatcher();

  @override
  Future<void> importCerts({required PgpImport import_});

  Future<bool> isStub({required String fingerprint});

  @override
  Stream<PgpCertWithIds> iterCerts();

  @override
  Stream<PgpCertWithIds> iterCertsSearch({required String pattern});

  @override
  Stream<PgpCertWithIds> iterCertsSearchKeyid({required String pattern});

  @override
  Stream<String> iterFingerprints();

  @override
  Future<List<CertSynopsis>> lookupSynopses({required KeyHandle kh});

  @override
  Future<List<(String, UserId)>> lookupSynopsesByEmail({required String email});

  @override
  Future<List<String>> lookupSynopsesByUserid({required UserId userid});

  @override
  Future<CertSynopsis> lookupSynopsisByFpr({required String fingerprint});

  @override
  Future<void> megaFlush();

  StoreNetwork networkFromFingerprints({required List<String> fingerprints});

  Future<void> signWithTrustLevel({
    required String signer,
    required String signee,
    required int level,
    required TrustLevel trust,
  });

  @override
  Future<List<CertSynopsis>> synopses();

  @override
  Future<List<Certification>> thirdPartyCertificationsOf({required String fpr});

  StoreNetwork unrootedNetwork();

  @override
  Future<void> updateCert({required ArcLazyCert cert});

  @override
  Future<void> updateRole({required String fingerprint, required String role});

  Future<void> uploadToKeyserver({
    required String fingerprint,
    required String server,
  });

  Future<VerifyResult> verifyQrAllCerts({required List<int> content});
}

abstract class PgpAppTrait {
  Future<List<PgpCertWithIds>> allOwnedCerts();

  Future<void> deleteCert({required String fingerprint});

  Future<void> deletePrivateKey({required String fingerprint});

  GenerateCert generateKey({required String email});

  Future<PgpCertWithIds?> getCertByRole({required String role});

  SqliteDb getDb();

  Watcher getWatcher();

  Future<void> megaFlush();

  Future<void> updateCert({required ArcLazyCert cert});

  Future<void> updateRole({required String fingerprint, required String role});
}

class Config {
  final PathBuf keystorePath;
  final PathBuf dbPath;

  const Config.raw({required this.keystorePath, required this.dbPath});

  factory Config({required String keystorePath, required String dbPath}) =>
      RustLib.instance.api.crateApiConfigNew(
        keystorePath: keystorePath,
        dbPath: dbPath,
      );

  @override
  int get hashCode => keystorePath.hashCode ^ dbPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          keystorePath == other.keystorePath &&
          dbPath == other.dbPath;
}
