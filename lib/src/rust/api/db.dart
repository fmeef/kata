// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'db.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `handle`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `certifications_of`, `certified_userids_of`, `certified_userids`, `get_fingerprints`, `lookup_synopses_by_email`, `lookup_synopses_by_userid`, `lookup_synopses`, `lookup_synopsis_by_fpr`, `synopses`, `third_party_certifications_of`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserID>>
abstract class UserId implements RustOpaqueInterface {}

abstract class CertStoreTrait {
  Future<List<CertificationSet>> certificationsOf({
    required String target,
    BigInt? minDepth,
  });

  Future<List<(String, UserId)>> certifiedUserids();

  Future<List<UserId>> certifiedUseridsOf({required String fpr});

  Future<List<String>> getFingerprints();

  Future<List<CertSynopsis>> lookupSynopses({required KeyHandle kh});

  Future<List<(String, UserId)>> lookupSynopsesByEmail({required String email});

  Future<List<String>> lookupSynopsesByUserid({required UserId userid});

  Future<CertSynopsis> lookupSynopsisByFpr({required String fingerprint});

  Future<List<CertSynopsis>> synopses();

  Future<List<Certification>> thirdPartyCertificationsOf({required String fpr});
}

class CertSynopsis {
  final String fingerprint;
  final String keyid;
  final KeyHandle keyHandle;
  final bool revoked;
  final List<String> userids;

  const CertSynopsis({
    required this.fingerprint,
    required this.keyid,
    required this.keyHandle,
    required this.revoked,
    required this.userids,
  });

  @override
  int get hashCode =>
      fingerprint.hashCode ^
      keyid.hashCode ^
      keyHandle.hashCode ^
      revoked.hashCode ^
      userids.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CertSynopsis &&
          runtimeType == other.runtimeType &&
          fingerprint == other.fingerprint &&
          keyid == other.keyid &&
          keyHandle == other.keyHandle &&
          revoked == other.revoked &&
          userids == other.userids;
}

class Certification {
  final String issuer;
  final String target;

  const Certification({required this.issuer, required this.target});

  @override
  int get hashCode => issuer.hashCode ^ target.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Certification &&
          runtimeType == other.runtimeType &&
          issuer == other.issuer &&
          target == other.target;
}

class CertificationSet {
  final String issuer;
  final String target;
  final List<(String?, List<Certification>)> certifications;

  const CertificationSet({
    required this.issuer,
    required this.target,
    required this.certifications,
  });

  @override
  int get hashCode =>
      issuer.hashCode ^ target.hashCode ^ certifications.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CertificationSet &&
          runtimeType == other.runtimeType &&
          issuer == other.issuer &&
          target == other.target &&
          certifications == other.certifications;
}

@freezed
sealed class KeyHandle with _$KeyHandle {
  const KeyHandle._();

  const factory KeyHandle.keyId(String field0) = KeyHandle_KeyId;
  const factory KeyHandle.fingerprint(String field0) = KeyHandle_Fingerprint;
}
